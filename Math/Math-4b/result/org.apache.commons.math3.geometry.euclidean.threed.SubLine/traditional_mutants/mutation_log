ROR_1:59:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 != Location.OUTSIDE  =>   loc1 == Location.OUTSIDE
ROR_2:59:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc2 != Location.OUTSIDE  =>   loc2 == Location.OUTSIDE
ROR_3:61:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 == Location.INSIDE  =>   loc1 != Location.INSIDE
ROR_4:61:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc2 == Location.INSIDE  =>   loc2 != Location.INSIDE
COR_1:59:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE  =>   loc1 != Location.OUTSIDE || loc2 != Location.OUTSIDE
COR_2:59:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE  =>   loc1 != Location.OUTSIDE ^ loc2 != Location.OUTSIDE
COR_3:61:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 == Location.INSIDE && loc2 == Location.INSIDE  =>   loc1 == Location.INSIDE || loc2 == Location.INSIDE
COR_4:61:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): loc1 == Location.INSIDE && loc2 == Location.INSIDE  =>   loc1 == Location.INSIDE ^ loc2 == Location.INSIDE
SDL_1:26:SubLine(org.apache.commons.math3.geometry.euclidean.threed.Line,org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet): this.line = line; this.remainingRegion = remainingRegion;  =>   this.remainingRegion = remainingRegion;
SDL_2:26:SubLine(org.apache.commons.math3.geometry.euclidean.threed.Line,org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet): this.line = line; this.remainingRegion = remainingRegion;  =>   this.line = line;
SDL_3:46:java.util.List_getSegments(): final java.util.List<Interval> list = remainingRegion.asList(); final java.util.List<Segment> segments = new java.util.ArrayList<Segment>(); for (; list;) {     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.threed.Segment( start, end, line ) ); } return segments;  =>   final java.util.List<Interval> list = remainingRegion.asList(); final java.util.List<Segment> segments = new java.util.ArrayList<Segment>(); return segments;
SDL_4:48:java.util.List_getSegments(): final org.apache.commons.math3.geometry.euclidean.threed.Vector3D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) ); final org.apache.commons.math3.geometry.euclidean.threed.Vector3D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) ); segments.add( new org.apache.commons.math3.geometry.euclidean.threed.Segment( start, end, line ) );  =>   final org.apache.commons.math3.geometry.euclidean.threed.Vector3D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) ); final org.apache.commons.math3.geometry.euclidean.threed.Vector3D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );
SDL_5:50:java.util.List_getSegments(): for (; list;) {     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.threed.Segment( start, end, line ) ); }  =>   for (;;) {     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.threed.Vector3D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.threed.Segment( start, end, line ) ); }
SDL_6:58:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): org.apache.commons.math3.geometry.euclidean.threed.Vector3D v1D = line.intersection( subLine.line ); org.apache.commons.math3.geometry.partitioning.Region.Location loc1 = remainingRegion.checkPoint( line.toSubSpace( v1D ) ); org.apache.commons.math3.geometry.partitioning.Region.Location loc2 = subLine.remainingRegion.checkPoint( subLine.line.toSubSpace( v1D ) ); if (includeEndPoints) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v1D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v1D : null; }  =>   org.apache.commons.math3.geometry.euclidean.threed.Vector3D v1D = line.intersection( subLine.line ); org.apache.commons.math3.geometry.partitioning.Region.Location loc1 = remainingRegion.checkPoint( line.toSubSpace( v1D ) ); org.apache.commons.math3.geometry.partitioning.Region.Location loc2 = subLine.remainingRegion.checkPoint( subLine.line.toSubSpace( v1D ) );
SDL_7:63:org.apache.commons.math3.geometry.euclidean.threed.Vector3D_intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine,boolean): if (includeEndPoints) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v1D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v1D : null; }  =>   if (true) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v1D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v1D : null; }
