AORB_1:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() * otherLine.getAngle()
AORB_2:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() / otherLine.getAngle()
AORB_3:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() % otherLine.getAngle()
AORB_4:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() + otherLine.getAngle()
AORB_5:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() * otherLine.getAngle()
AORB_6:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() / otherLine.getAngle()
AORB_7:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() % otherLine.getAngle()
AORB_8:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane):thisLine.getAngle() - otherLine.getAngle() => thisLine.getAngle() + otherLine.getAngle()
ROR_1:63:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 != Location.OUTSIDE  =>   loc1 == Location.OUTSIDE
ROR_2:63:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc2 != Location.OUTSIDE  =>   loc2 == Location.OUTSIDE
ROR_3:65:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 == Location.INSIDE  =>   loc1 != Location.INSIDE
ROR_4:65:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc2 == Location.INSIDE  =>   loc2 != Location.INSIDE
ROR_5:85:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): crossing == null  =>   crossing != null
ROR_6:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global > -1.0e-10
ROR_7:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global >= -1.0e-10
ROR_8:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global <= -1.0e-10
ROR_9:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global == -1.0e-10
ROR_10:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global != -1.0e-10
ROR_11:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   true
ROR_12:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   false
ROR_13:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   global >= 1.0e-10
ROR_14:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   global < 1.0e-10
ROR_15:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   global <= 1.0e-10
ROR_16:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   global == 1.0e-10
ROR_17:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   global != 1.0e-10
ROR_18:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   true
ROR_19:87:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): global > 1.0e-10  =>   false
ROR_20:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) > 0
ROR_21:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) >= 0
ROR_22:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) <= 0
ROR_23:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) == 0
ROR_24:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) != 0
ROR_25:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   true
ROR_26:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   false
ROR_27:99:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): crossing == null  =>   crossing != null
ROR_28:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global > -1.0e-10
ROR_29:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global >= -1.0e-10
ROR_30:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global <= -1.0e-10
ROR_31:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global == -1.0e-10
ROR_32:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   global != -1.0e-10
ROR_33:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   true
ROR_34:101:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): global < -1.0e-10  =>   false
ROR_35:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) > 0
ROR_36:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) >= 0
ROR_37:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) <= 0
ROR_38:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) == 0
ROR_39:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) != 0
ROR_40:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   true
ROR_41:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0  =>   false
COR_1:63:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE  =>   loc1 != Location.OUTSIDE || loc2 != Location.OUTSIDE
COR_2:63:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE  =>   loc1 != Location.OUTSIDE ^ loc2 != Location.OUTSIDE
COR_3:65:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 == Location.INSIDE && loc2 == Location.INSIDE  =>   loc1 == Location.INSIDE || loc2 == Location.INSIDE
COR_4:65:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): loc1 == Location.INSIDE && loc2 == Location.INSIDE  =>   loc1 == Location.INSIDE ^ loc2 == Location.INSIDE
SDL_1:48:java.util.List_getSegments(): final org.apache.commons.math3.geometry.euclidean.twod.Line line = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final java.util.List<Interval> list = ((org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet) getRemainingRegion()).asList(); final java.util.List<Segment> segments = new java.util.ArrayList<Segment>(); for (; list;) {     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.twod.Segment( start, end, line ) ); } return segments;  =>   final org.apache.commons.math3.geometry.euclidean.twod.Line line = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final java.util.List<Interval> list = ((org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet) getRemainingRegion()).asList(); final java.util.List<Segment> segments = new java.util.ArrayList<Segment>(); return segments;
SDL_2:50:java.util.List_getSegments(): final org.apache.commons.math3.geometry.euclidean.twod.Vector2D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) ); final org.apache.commons.math3.geometry.euclidean.twod.Vector2D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) ); segments.add( new org.apache.commons.math3.geometry.euclidean.twod.Segment( start, end, line ) );  =>   final org.apache.commons.math3.geometry.euclidean.twod.Vector2D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) ); final org.apache.commons.math3.geometry.euclidean.twod.Vector2D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );
SDL_3:52:java.util.List_getSegments(): for (; list;) {     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.twod.Segment( start, end, line ) ); }  =>   for (;;) {     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D start = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getInf() ) );     final org.apache.commons.math3.geometry.euclidean.twod.Vector2D end = line.toSpace( new org.apache.commons.math3.geometry.euclidean.oned.Vector1D( interval.getSup() ) );     segments.add( new org.apache.commons.math3.geometry.euclidean.twod.Segment( start, end, line ) ); }
SDL_4:62:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): org.apache.commons.math3.geometry.euclidean.twod.Line line1 = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); org.apache.commons.math3.geometry.euclidean.twod.Line line2 = (org.apache.commons.math3.geometry.euclidean.twod.Line) subLine.getHyperplane(); org.apache.commons.math3.geometry.euclidean.twod.Vector2D v2D = line1.intersection( line2 ); org.apache.commons.math3.geometry.partitioning.Region.Location loc1 = getRemainingRegion().checkPoint( line1.toSubSpace( v2D ) ); org.apache.commons.math3.geometry.partitioning.Region.Location loc2 = subLine.getRemainingRegion().checkPoint( line2.toSubSpace( v2D ) ); if (includeEndPoints) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v2D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v2D : null; }  =>   org.apache.commons.math3.geometry.euclidean.twod.Line line1 = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); org.apache.commons.math3.geometry.euclidean.twod.Line line2 = (org.apache.commons.math3.geometry.euclidean.twod.Line) subLine.getHyperplane(); org.apache.commons.math3.geometry.euclidean.twod.Vector2D v2D = line1.intersection( line2 ); org.apache.commons.math3.geometry.partitioning.Region.Location loc1 = getRemainingRegion().checkPoint( line1.toSubSpace( v2D ) ); org.apache.commons.math3.geometry.partitioning.Region.Location loc2 = subLine.getRemainingRegion().checkPoint( line2.toSubSpace( v2D ) );
SDL_5:67:org.apache.commons.math3.geometry.euclidean.twod.Vector2D_intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine,boolean): if (includeEndPoints) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v2D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v2D : null; }  =>   if (true) {     return loc1 != Location.OUTSIDE && loc2 != Location.OUTSIDE ? v2D : null; } else {     return loc1 == Location.INSIDE && loc2 == Location.INSIDE ? v2D : null; }
SDL_6:88:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): final org.apache.commons.math3.geometry.euclidean.twod.Line thisLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final org.apache.commons.math3.geometry.euclidean.twod.Line otherLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) hyperplane; final org.apache.commons.math3.geometry.euclidean.twod.Vector2D crossing = thisLine.intersection( otherLine ); if (crossing == null) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? Side.MINUS : global > 1.0e-10 ? Side.PLUS : Side.HYPER; } final boolean direct = FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0; final org.apache.commons.math3.geometry.euclidean.oned.Vector1D x = thisLine.toSubSpace( crossing ); return getRemainingRegion().side( new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, direct ) );  =>   final org.apache.commons.math3.geometry.euclidean.twod.Line thisLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final org.apache.commons.math3.geometry.euclidean.twod.Line otherLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) hyperplane; final org.apache.commons.math3.geometry.euclidean.twod.Vector2D crossing = thisLine.intersection( otherLine ); final boolean direct = FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0; final org.apache.commons.math3.geometry.euclidean.oned.Vector1D x = thisLine.toSubSpace( crossing ); return getRemainingRegion().side( new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, direct ) );
SDL_7:89:org.apache.commons.math3.geometry.partitioning.Side_side(org.apache.commons.math3.geometry.partitioning.Hyperplane): if (crossing == null) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? Side.MINUS : global > 1.0e-10 ? Side.PLUS : Side.HYPER; }  =>   if (true) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? Side.MINUS : global > 1.0e-10 ? Side.PLUS : Side.HYPER; }
SDL_8:107:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): final org.apache.commons.math3.geometry.euclidean.twod.Line thisLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final org.apache.commons.math3.geometry.euclidean.twod.Line otherLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) hyperplane; final org.apache.commons.math3.geometry.euclidean.twod.Vector2D crossing = thisLine.intersection( otherLine ); if (crossing == null) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? new SplitSubHyperplane<Euclidean2D>( null, this ) : new SplitSubHyperplane<Euclidean2D>( this, null ); } final boolean direct = FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0; final org.apache.commons.math3.geometry.euclidean.oned.Vector1D x = thisLine.toSubSpace( crossing ); final org.apache.commons.math3.geometry.partitioning.SubHyperplane<Euclidean1D> subPlus = (new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, !direct )).wholeHyperplane(); final org.apache.commons.math3.geometry.partitioning.SubHyperplane<Euclidean1D> subMinus = (new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, direct )).wholeHyperplane(); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree( false ).split( subMinus ); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty( splitTree.getPlus() ) ? new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ) : new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( subPlus, new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ), splitTree.getPlus(), null ); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty( splitTree.getMinus() ) ? new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ) : new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( subMinus, new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ), splitTree.getMinus(), null ); return new SplitSubHyperplane<Euclidean2D>( new org.apache.commons.math3.geometry.euclidean.twod.SubLine( thisLine.copySelf(), new org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet( plusTree ) ), new org.apache.commons.math3.geometry.euclidean.twod.SubLine( thisLine.copySelf(), new org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet( minusTree ) ) );  =>   final org.apache.commons.math3.geometry.euclidean.twod.Line thisLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) getHyperplane(); final org.apache.commons.math3.geometry.euclidean.twod.Line otherLine = (org.apache.commons.math3.geometry.euclidean.twod.Line) hyperplane; final org.apache.commons.math3.geometry.euclidean.twod.Vector2D crossing = thisLine.intersection( otherLine ); final boolean direct = FastMath.sin( thisLine.getAngle() - otherLine.getAngle() ) < 0; final org.apache.commons.math3.geometry.euclidean.oned.Vector1D x = thisLine.toSubSpace( crossing ); final org.apache.commons.math3.geometry.partitioning.SubHyperplane<Euclidean1D> subPlus = (new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, !direct )).wholeHyperplane(); final org.apache.commons.math3.geometry.partitioning.SubHyperplane<Euclidean1D> subMinus = (new org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint( x, direct )).wholeHyperplane(); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree( false ).split( subMinus ); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty( splitTree.getPlus() ) ? new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ) : new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( subPlus, new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ), splitTree.getPlus(), null ); final org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty( splitTree.getMinus() ) ? new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ) : new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( subMinus, new org.apache.commons.math3.geometry.partitioning.BSPTree<Euclidean1D>( Boolean.FALSE ), splitTree.getMinus(), null ); return new SplitSubHyperplane<Euclidean2D>( new org.apache.commons.math3.geometry.euclidean.twod.SubLine( thisLine.copySelf(), new org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet( plusTree ) ), new org.apache.commons.math3.geometry.euclidean.twod.SubLine( thisLine.copySelf(), new org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet( minusTree ) ) );
SDL_9:103:SplitSubHyperplane_split(org.apache.commons.math3.geometry.partitioning.Hyperplane): if (crossing == null) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? new SplitSubHyperplane<Euclidean2D>( null, this ) : new SplitSubHyperplane<Euclidean2D>( this, null ); }  =>   if (true) {     final double global = otherLine.getOffset( thisLine );     return global < -1.0e-10 ? new SplitSubHyperplane<Euclidean2D>( null, this ) : new SplitSubHyperplane<Euclidean2D>( this, null ); }
