AORB_5:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 * fVal
AORB_6:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 / fVal
AORB_7:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 % fVal
AORB_8:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 + fVal
AORB_9:98:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 * fVal
AORB_10:98:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 / fVal
AORB_11:98:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 % fVal
AORB_12:98:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 - fVal => fX2 + fVal
AORB_13:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX * fVal
AORB_14:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX / fVal
AORB_15:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX % fVal
AORB_16:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX + fVal
AORB_17:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX - fVal) => 2 / (fX - fVal)
AORB_18:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX - fVal) => 2 % (fX - fVal)
AORB_19:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX - fVal) => 2 + (fX - fVal)
AORB_20:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX - fVal) => 2 - (fX - fVal)
AORB_21:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():FastMath.abs( fX ) + FastMath.abs( fVal ) => FastMath.abs( fX ) * FastMath.abs( fVal )
AORB_22:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():FastMath.abs( fX ) + FastMath.abs( fVal ) => FastMath.abs( fX ) / FastMath.abs( fVal )
AORB_23:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():FastMath.abs( fX ) + FastMath.abs( fVal ) => FastMath.abs( fX ) % FastMath.abs( fVal )
AORB_24:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():FastMath.abs( fX ) + FastMath.abs( fVal ) => FastMath.abs( fX ) - FastMath.abs( fVal )
AORB_25:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) => relativeThreshold / (FastMath.abs( fX ) + FastMath.abs( fVal ))
AORB_26:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) => relativeThreshold % (FastMath.abs( fX ) + FastMath.abs( fVal ))
AORB_27:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) => relativeThreshold + (FastMath.abs( fX ) + FastMath.abs( fVal ))
AORB_28:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) => relativeThreshold - (FastMath.abs( fX ) + FastMath.abs( fVal ))
AORB_29:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold => relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) * absoluteThreshold
AORB_30:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold => relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) / absoluteThreshold
AORB_31:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold => relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) % absoluteThreshold
AORB_32:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold => relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) - absoluteThreshold
AORB_33:120:org.apache.commons.math3.optim.PointValuePair_doOptimize():x[i] - x1[i] => x[i] * x1[i]
AORB_34:120:org.apache.commons.math3.optim.PointValuePair_doOptimize():x[i] - x1[i] => x[i] / x1[i]
AORB_35:120:org.apache.commons.math3.optim.PointValuePair_doOptimize():x[i] - x1[i] => x[i] % x1[i]
AORB_36:120:org.apache.commons.math3.optim.PointValuePair_doOptimize():x[i] - x1[i] => x[i] + x1[i]
AORB_37:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] => 2 / x[i]
AORB_38:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] => 2 % x[i]
AORB_39:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] => 2 + x[i]
AORB_40:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] => 2 - x[i]
AORB_41:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] - x1[i] => 2 * x[i] * x1[i]
AORB_42:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] - x1[i] => 2 * x[i] / x1[i]
AORB_43:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] - x1[i] => 2 * x[i] % x1[i]
AORB_44:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * x[i] - x1[i] => 2 * x[i] + x1[i]
AORB_45:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 => fX * fX2
AORB_46:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 => fX / fX2
AORB_47:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 => fX % fX2
AORB_48:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 => fX - fX2
AORB_49:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * fVal => 2 / fVal
AORB_50:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * fVal => 2 % fVal
AORB_51:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * fVal => 2 + fVal
AORB_52:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * fVal => 2 - fVal
AORB_53:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 - 2 * fVal => (fX + fX2) * (2 * fVal)
AORB_54:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 - 2 * fVal => (fX + fX2) / (2 * fVal)
AORB_55:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 - 2 * fVal => (fX + fX2) % (2 * fVal)
AORB_56:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX + fX2 - 2 * fVal => fX + fX2 + 2 * fVal
AORB_57:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX + fX2 - 2 * fVal) => 2 / (fX + fX2 - 2 * fVal)
AORB_58:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX + fX2 - 2 * fVal) => 2 % (fX + fX2 - 2 * fVal)
AORB_59:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX + fX2 - 2 * fVal) => 2 + (fX + fX2 - 2 * fVal)
AORB_60:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():2 * (fX + fX2 - 2 * fVal) => 2 - (fX + fX2 - 2 * fVal)
AORB_61:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX * fVal
AORB_62:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX / fVal
AORB_63:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX % fVal
AORB_64:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal => fX + fVal
AORB_65:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal - delta => (fX - fVal) * delta
AORB_66:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal - delta => (fX - fVal) / delta
AORB_67:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal - delta => (fX - fVal) % delta
AORB_68:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fVal - delta => fX - fVal + delta
AORB_69:128:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp * temp => temp / temp
AORB_70:128:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp * temp => temp % temp
AORB_71:128:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp * temp => temp + temp
AORB_72:128:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp * temp => temp - temp
AORB_73:129:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fX2 => fX * fX2
AORB_74:129:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fX2 => fX / fX2
AORB_75:129:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fX2 => fX % fX2
AORB_76:129:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX - fX2 => fX + fX2
AORB_77:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp => delta / temp
AORB_78:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp => delta % temp
AORB_79:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp => delta + temp
AORB_80:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp => delta - temp
AORB_81:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp * temp => delta * temp / temp
AORB_82:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp * temp => delta * temp % temp
AORB_83:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp * temp => delta * temp + temp
AORB_84:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta * temp * temp => delta * temp - temp
AORB_85:137:org.apache.commons.math3.optim.PointValuePair_doOptimize():n - 1 => n * 1
AORB_86:137:org.apache.commons.math3.optim.PointValuePair_doOptimize():n - 1 => n / 1
AORB_87:137:org.apache.commons.math3.optim.PointValuePair_doOptimize():n - 1 => n % 1
AORB_88:137:org.apache.commons.math3.optim.PointValuePair_doOptimize():n - 1 => n + 1
AORB_89:151:double_newPointAndDirection(double,double,double):d[i] * optimum => d[i] / optimum
AORB_90:151:double_newPointAndDirection(double,double,double):d[i] * optimum => d[i] % optimum
AORB_91:151:double_newPointAndDirection(double,double,double):d[i] * optimum => d[i] + optimum
AORB_92:151:double_newPointAndDirection(double,double,double):d[i] * optimum => d[i] - optimum
AORB_93:152:double_newPointAndDirection(double,double,double):p[i] + nD[i] => p[i] * nD[i]
AORB_94:152:double_newPointAndDirection(double,double,double):p[i] + nD[i] => p[i] / nD[i]
AORB_95:152:double_newPointAndDirection(double,double,double):p[i] + nD[i] => p[i] % nD[i]
AORB_96:152:double_newPointAndDirection(double,double,double):p[i] + nD[i] => p[i] - nD[i]
AOIU_1:40:PowellOptimizer(double,double,org.apache.commons.math3.optim.ConvergenceChecker):rel => -rel
AOIU_2:40:PowellOptimizer(double,double,org.apache.commons.math3.optim.ConvergenceChecker):abs => -abs
AOIU_3:40:PowellOptimizer(double,double,org.apache.commons.math3.optim.ConvergenceChecker):rel => -rel
AOIU_4:40:PowellOptimizer(double,double,org.apache.commons.math3.optim.ConvergenceChecker):abs => -abs
AOIU_5:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):rel => -rel
AOIU_6:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):MIN_RELATIVE_TOLERANCE => -MIN_RELATIVE_TOLERANCE
AOIU_7:47:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):rel => -rel
AOIU_8:47:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):MIN_RELATIVE_TOLERANCE => -MIN_RELATIVE_TOLERANCE
AOIU_9:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):abs => -abs
AOIU_10:50:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):abs => -abs
AOIU_11:52:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):rel => -rel
AOIU_12:53:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):abs => -abs
AOIU_13:54:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):lineRel => -lineRel
AOIU_14:54:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker):lineAbs => -lineAbs
AOIU_15:59:PowellOptimizer(double,double):rel => -rel
AOIU_16:59:PowellOptimizer(double,double):abs => -abs
AOIU_17:64:PowellOptimizer(double,double,double,double):rel => -rel
AOIU_18:64:PowellOptimizer(double,double,double,double):abs => -abs
AOIU_19:64:PowellOptimizer(double,double,double,double):lineRel => -lineRel
AOIU_20:64:PowellOptimizer(double,double,double,double):lineAbs => -lineAbs
AOIU_21:72:org.apache.commons.math3.optim.PointValuePair_doOptimize():guess.length => -guess.length
AOIU_22:73:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_23:73:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_24:74:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_25:74:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_26:84:org.apache.commons.math3.optim.PointValuePair_doOptimize():fVal => -fVal
AOIU_27:89:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_28:89:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_29:90:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_30:91:org.apache.commons.math3.optim.PointValuePair_doOptimize():fVal => -fVal
AOIU_31:95:org.apache.commons.math3.optim.PointValuePair_doOptimize():alphaMin => -alphaMin
AOIU_32:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 => -fX2
AOIU_33:97:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta => -delta
AOIU_34:98:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 => -fX2
AOIU_35:99:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_36:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_37:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():relativeThreshold => -relativeThreshold
AOIU_38:102:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_39:103:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_40:104:org.apache.commons.math3.optim.PointValuePair_doOptimize():fVal => -fVal
AOIU_41:107:org.apache.commons.math3.optim.PointValuePair_doOptimize():iter => -iter
AOIU_42:112:org.apache.commons.math3.optim.PointValuePair_doOptimize():fVal => -fVal
AOIU_43:112:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_44:114:org.apache.commons.math3.optim.PointValuePair_doOptimize():fVal => -fVal
AOIU_45:114:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_46:117:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_47:118:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_48:119:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_49:119:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_50:120:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_51:121:org.apache.commons.math3.optim.PointValuePair_doOptimize():i => -i
AOIU_52:125:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_53:125:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX2 => -fX2
AOIU_54:126:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_55:127:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_56:128:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp => -temp
AOIU_57:129:org.apache.commons.math3.optim.PointValuePair_doOptimize():fX => -fX
AOIU_58:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():delta => -delta
AOIU_59:130:org.apache.commons.math3.optim.PointValuePair_doOptimize():temp => -temp
AOIU_60:131:org.apache.commons.math3.optim.PointValuePair_doOptimize():t => -t
AOIU_61:135:org.apache.commons.math3.optim.PointValuePair_doOptimize():alphaMin => -alphaMin
AOIU_62:137:org.apache.commons.math3.optim.PointValuePair_doOptimize():n => -n
AOIU_63:138:org.apache.commons.math3.optim.PointValuePair_doOptimize():lastInd => -lastInd
AOIU_64:147:double_newPointAndDirection(double,double,double):p.length => -p.length
AOIU_65:148:double_newPointAndDirection(double,double,double):n => -n
AOIU_66:149:double_newPointAndDirection(double,double,double):n => -n
AOIU_67:150:double_newPointAndDirection(double,double,double):i => -i
AOIU_68:150:double_newPointAndDirection(double,double,double):n => -n
AOIU_69:151:double_newPointAndDirection(double,double,double):i => -i
AOIU_70:151:double_newPointAndDirection(double,double,double):optimum => -optimum
AOIU_71:152:double_newPointAndDirection(double,double,double):i => -i
AOIU_72:165:double_newPointAndDirection(double,double,double):Double.MIN_VALUE => -Double.MIN_VALUE
AOIU_73:171:LineSearch(double,double):REL_TOL_UNUSED => -REL_TOL_UNUSED
AOIU_74:171:LineSearch(double,double):ABS_TOL_UNUSED => -ABS_TOL_UNUSED
AOIU_75:171:LineSearch(double,double):rel => -rel
AOIU_76:171:LineSearch(double,double):abs => -abs
AOIU_77:176:org.apache.commons.math3.optim.univariate.UnivariatePointValuePair_search(double,double):p.length => -p.length
ROR_1:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   rel > MIN_RELATIVE_TOLERANCE
ROR_2:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   rel >= MIN_RELATIVE_TOLERANCE
ROR_3:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   rel <= MIN_RELATIVE_TOLERANCE
ROR_4:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   rel == MIN_RELATIVE_TOLERANCE
ROR_5:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   rel != MIN_RELATIVE_TOLERANCE
ROR_6:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   true
ROR_7:46:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): rel < MIN_RELATIVE_TOLERANCE  =>   false
ROR_8:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   abs > 0
ROR_9:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   abs >= 0
ROR_10:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   abs < 0
ROR_11:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   abs == 0
ROR_12:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   abs != 0
ROR_13:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   true
ROR_14:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): abs <= 0  =>   false
ROR_15:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i > n
ROR_16:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i >= n
ROR_17:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i <= n
ROR_18:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i == n
ROR_19:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i != n
ROR_20:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   true
ROR_21:74:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   false
ROR_22:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i > n
ROR_23:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i >= n
ROR_24:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i <= n
ROR_25:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i == n
ROR_26:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i != n
ROR_27:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   true
ROR_28:89:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   false
ROR_29:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   fX2 - fVal >= delta
ROR_30:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   fX2 - fVal < delta
ROR_31:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   fX2 - fVal <= delta
ROR_32:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   fX2 - fVal == delta
ROR_33:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   fX2 - fVal != delta
ROR_34:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   true
ROR_35:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX2 - fVal > delta  =>   false
ROR_36:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   2 * (fX - fVal) > relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold
ROR_37:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   2 * (fX - fVal) >= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold
ROR_38:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   2 * (fX - fVal) < relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold
ROR_39:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   2 * (fX - fVal) == relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold
ROR_40:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   2 * (fX - fVal) != relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold
ROR_41:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   true
ROR_42:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold  =>   false
ROR_43:106:org.apache.commons.math3.optim.PointValuePair_doOptimize(): checker != null  =>   checker == null
ROR_44:111:org.apache.commons.math3.optim.PointValuePair_doOptimize(): goal == GoalType.MINIMIZE  =>   goal != GoalType.MINIMIZE
ROR_45:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   fVal > fX
ROR_46:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   fVal >= fX
ROR_47:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   fVal <= fX
ROR_48:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   fVal == fX
ROR_49:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   fVal != fX
ROR_50:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   true
ROR_51:112:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal < fX  =>   false
ROR_52:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   fVal >= fX
ROR_53:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   fVal < fX
ROR_54:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   fVal <= fX
ROR_55:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   fVal == fX
ROR_56:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   fVal != fX
ROR_57:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   true
ROR_58:114:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fVal > fX  =>   false
ROR_59:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i > n
ROR_60:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i >= n
ROR_61:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i <= n
ROR_62:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i == n
ROR_63:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   i != n
ROR_64:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   true
ROR_65:119:org.apache.commons.math3.optim.PointValuePair_doOptimize(): i < n  =>   false
ROR_66:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   fX >= fX2
ROR_67:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   fX < fX2
ROR_68:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   fX <= fX2
ROR_69:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   fX == fX2
ROR_70:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   fX != fX2
ROR_71:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   true
ROR_72:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): fX > fX2  =>   false
ROR_73:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   t > 0.0
ROR_74:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   t >= 0.0
ROR_75:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   t <= 0.0
ROR_76:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   t == 0.0
ROR_77:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   t != 0.0
ROR_78:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   true
ROR_79:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): t < 0.0  =>   false
ROR_80:150:double_newPointAndDirection(double,double,double): i < n  =>   i > n
ROR_81:150:double_newPointAndDirection(double,double,double): i < n  =>   i >= n
ROR_82:150:double_newPointAndDirection(double,double,double): i < n  =>   i <= n
ROR_83:150:double_newPointAndDirection(double,double,double): i < n  =>   i == n
ROR_84:150:double_newPointAndDirection(double,double,double): i < n  =>   i != n
ROR_85:150:double_newPointAndDirection(double,double,double): i < n  =>   true
ROR_86:150:double_newPointAndDirection(double,double,double): i < n  =>   false
ROR_94:197:void_checkParameters(): getLowerBound() != null  =>   getLowerBound() == null
ROR_95:197:void_checkParameters(): getUpperBound() != null  =>   getUpperBound() == null
COR_1:197:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null && getUpperBound() != null
COR_2:197:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null ^ getUpperBound() != null
SDL_1:52:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );  =>   if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );
SDL_2:52:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );  =>   if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );
SDL_3:54:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );  =>   if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );
SDL_4:54:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );  =>   if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );
SDL_5:54:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs; line = new org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch( lineRel, lineAbs );  =>   if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); } if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); } relativeThreshold = rel; absoluteThreshold = abs;
SDL_6:47:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true );  =>  
SDL_7:49:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (rel < MIN_RELATIVE_TOLERANCE) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.NumberIsTooSmallException( rel, MIN_RELATIVE_TOLERANCE, true ); }
SDL_8:50:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs );  =>  
SDL_9:52:PowellOptimizer(double,double,double,double,org.apache.commons.math3.optim.ConvergenceChecker): if (abs <= 0) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.NotStrictlyPositiveException( abs ); }
SDL_10:142:org.apache.commons.math3.optim.PointValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) {     direc[i][i] = 1; } final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0; while (true) {     ++iter;     double fX = fVal;     double fX2 = 0;     double delta = 0;     int bigInd = 0;     double alphaMin = 0;     for (int i = 0; i < n; i++) {         final double[] d = MathArrays.copyOf( direc[i] );         fX2 = fVal;         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         if (fX2 - fVal > delta) {             delta = fX2 - fVal;             bigInd = i;         }     }     boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold;     final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX );     final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal );     if (!stop) {         if (checker != null) {             stop = checker.converged( iter, previous, current );         }     }     if (stop) {         if (goal == GoalType.MINIMIZE) {             return fVal < fX ? current : previous;         } else {             return fVal > fX ? current : previous;         }     }     final double[] d = new double[n];     final double[] x2 = new double[n];     for (int i = 0; i < n; i++) {         d[i] = x[i] - x1[i];         x2[i] = 2 * x[i] - x1[i];     }     x1 = x.clone();     fX2 = computeObjectiveValue( x2 );     if (fX > fX2) {         double t = 2 * (fX + fX2 - 2 * fVal);         double temp = fX - fVal - delta;         t *= temp * temp;         temp = fX - fX2;         t -= delta * temp * temp;         if (t < 0.0) {             final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );             fVal = optimum.getValue();             alphaMin = optimum.getPoint();             final double[][] result = newPointAndDirection( x, d, alphaMin );             x = result[0];             final int lastInd = n - 1;             direc[bigInd] = direc[lastInd];             direc[lastInd] = result[1];         }     } }  =>   final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) {     direc[i][i] = 1; } final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0; while (true) {     ++iter;     double fX = fVal;     double fX2 = 0;     double delta = 0;     int bigInd = 0;     double alphaMin = 0;     for (int i = 0; i < n; i++) {         final double[] d = MathArrays.copyOf( direc[i] );         fX2 = fVal;         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         if (fX2 - fVal > delta) {             delta = fX2 - fVal;             bigInd = i;         }     }     boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold;     final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX );     final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal );     if (!stop) {         if (checker != null) {             stop = checker.converged( iter, previous, current );         }     }     if (stop) {         if (goal == GoalType.MINIMIZE) {             return fVal < fX ? current : previous;         } else {             return fVal > fX ? current : previous;         }     }     final double[] d = new double[n];     final double[] x2 = new double[n];     for (int i = 0; i < n; i++) {         d[i] = x[i] - x1[i];         x2[i] = 2 * x[i] - x1[i];     }     x1 = x.clone();     fX2 = computeObjectiveValue( x2 );     if (fX > fX2) {         double t = 2 * (fX + fX2 - 2 * fVal);         double temp = fX - fVal - delta;         t *= temp * temp;         temp = fX - fX2;         t -= delta * temp * temp;         if (t < 0.0) {             final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );             fVal = optimum.getValue();             alphaMin = optimum.getPoint();             final double[][] result = newPointAndDirection( x, d, alphaMin );             x = result[0];             final int lastInd = n - 1;             direc[bigInd] = direc[lastInd];             direc[lastInd] = result[1];         }     } }
SDL_11:140:org.apache.commons.math3.optim.PointValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) {     direc[i][i] = 1; } final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0; while (true) {     ++iter;     double fX = fVal;     double fX2 = 0;     double delta = 0;     int bigInd = 0;     double alphaMin = 0;     for (int i = 0; i < n; i++) {         final double[] d = MathArrays.copyOf( direc[i] );         fX2 = fVal;         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         if (fX2 - fVal > delta) {             delta = fX2 - fVal;             bigInd = i;         }     }     boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold;     final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX );     final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal );     if (!stop) {         if (checker != null) {             stop = checker.converged( iter, previous, current );         }     }     if (stop) {         if (goal == GoalType.MINIMIZE) {             return fVal < fX ? current : previous;         } else {             return fVal > fX ? current : previous;         }     }     final double[] d = new double[n];     final double[] x2 = new double[n];     for (int i = 0; i < n; i++) {         d[i] = x[i] - x1[i];         x2[i] = 2 * x[i] - x1[i];     }     x1 = x.clone();     fX2 = computeObjectiveValue( x2 );     if (fX > fX2) {         double t = 2 * (fX + fX2 - 2 * fVal);         double temp = fX - fVal - delta;         t *= temp * temp;         temp = fX - fX2;         t -= delta * temp * temp;         if (t < 0.0) {             final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );             fVal = optimum.getValue();             alphaMin = optimum.getPoint();             final double[][] result = newPointAndDirection( x, d, alphaMin );             x = result[0];             final int lastInd = n - 1;             direc[bigInd] = direc[lastInd];             direc[lastInd] = result[1];         }     } }  =>   checkParameters(); final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0; while (true) {     ++iter;     double fX = fVal;     double fX2 = 0;     double delta = 0;     int bigInd = 0;     double alphaMin = 0;     for (int i = 0; i < n; i++) {         final double[] d = MathArrays.copyOf( direc[i] );         fX2 = fVal;         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         if (fX2 - fVal > delta) {             delta = fX2 - fVal;             bigInd = i;         }     }     boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold;     final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX );     final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal );     if (!stop) {         if (checker != null) {             stop = checker.converged( iter, previous, current );         }     }     if (stop) {         if (goal == GoalType.MINIMIZE) {             return fVal < fX ? current : previous;         } else {             return fVal > fX ? current : previous;         }     }     final double[] d = new double[n];     final double[] x2 = new double[n];     for (int i = 0; i < n; i++) {         d[i] = x[i] - x1[i];         x2[i] = 2 * x[i] - x1[i];     }     x1 = x.clone();     fX2 = computeObjectiveValue( x2 );     if (fX > fX2) {         double t = 2 * (fX + fX2 - 2 * fVal);         double temp = fX - fVal - delta;         t *= temp * temp;         temp = fX - fX2;         t -= delta * temp * temp;         if (t < 0.0) {             final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );             fVal = optimum.getValue();             alphaMin = optimum.getPoint();             final double[][] result = newPointAndDirection( x, d, alphaMin );             x = result[0];             final int lastInd = n - 1;             direc[bigInd] = direc[lastInd];             direc[lastInd] = result[1];         }     } }
SDL_12:82:org.apache.commons.math3.optim.PointValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) {     direc[i][i] = 1; } final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0; while (true) {     ++iter;     double fX = fVal;     double fX2 = 0;     double delta = 0;     int bigInd = 0;     double alphaMin = 0;     for (int i = 0; i < n; i++) {         final double[] d = MathArrays.copyOf( direc[i] );         fX2 = fVal;         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         if (fX2 - fVal > delta) {             delta = fX2 - fVal;             bigInd = i;         }     }     boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold;     final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX );     final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal );     if (!stop) {         if (checker != null) {             stop = checker.converged( iter, previous, current );         }     }     if (stop) {         if (goal == GoalType.MINIMIZE) {             return fVal < fX ? current : previous;         } else {             return fVal > fX ? current : previous;         }     }     final double[] d = new double[n];     final double[] x2 = new double[n];     for (int i = 0; i < n; i++) {         d[i] = x[i] - x1[i];         x2[i] = 2 * x[i] - x1[i];     }     x1 = x.clone();     fX2 = computeObjectiveValue( x2 );     if (fX > fX2) {         double t = 2 * (fX + fX2 - 2 * fVal);         double temp = fX - fVal - delta;         t *= temp * temp;         temp = fX - fX2;         t -= delta * temp * temp;         if (t < 0.0) {             final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );             fVal = optimum.getValue();             alphaMin = optimum.getPoint();             final double[][] result = newPointAndDirection( x, d, alphaMin );             x = result[0];             final int lastInd = n - 1;             direc[bigInd] = direc[lastInd];             direc[lastInd] = result[1];         }     } }  =>   checkParameters(); final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) {     direc[i][i] = 1; } final org.apache.commons.math3.optim.ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue( x ); double[] x1 = x.clone(); int iter = 0;
SDL_13:75:org.apache.commons.math3.optim.PointValuePair_doOptimize(): direc[i][i] = 1;  =>  
SDL_14:77:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     direc[i][i] = 1; }  =>   for (int i = 0;; i++) {     direc[i][i] = 1; }
SDL_15:77:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     direc[i][i] = 1; }  =>   for (int i = 0; i < n;) {     direc[i][i] = 1; }
SDL_16:141:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_17:129:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_18:137:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_19:135:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_20:138:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_21:141:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_22:141:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_23:125:org.apache.commons.math3.optim.PointValuePair_doOptimize(): ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 ); if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } } boolean stop = 2 * (fX - fVal) <= relativeThreshold * (FastMath.abs( fX ) + FastMath.abs( fVal )) + absoluteThreshold; final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair( x1, fX ); final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair( x, fVal ); if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } } if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue( x2 );
SDL_24:100:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   final double[] d = MathArrays.copyOf( direc[i] ); final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }
SDL_25:100:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }
SDL_26:100:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }
SDL_27:100:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }
SDL_28:97:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   final double[] d = MathArrays.copyOf( direc[i] ); fX2 = fVal; final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0];
SDL_29:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } }  =>   for (int i = 0;; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } }
SDL_30:102:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } }  =>   for (int i = 0; i < n;) {     final double[] d = MathArrays.copyOf( direc[i] );     fX2 = fVal;     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     if (fX2 - fVal > delta) {         delta = fX2 - fVal;         bigInd = i;     } }
SDL_31:99:org.apache.commons.math3.optim.PointValuePair_doOptimize(): delta = fX2 - fVal; bigInd = i;  =>   bigInd = i;
SDL_32:99:org.apache.commons.math3.optim.PointValuePair_doOptimize(): delta = fX2 - fVal; bigInd = i;  =>   delta = fX2 - fVal;
SDL_33:101:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (fX2 - fVal > delta) {     delta = fX2 - fVal;     bigInd = i; }  =>   if (true) {     delta = fX2 - fVal;     bigInd = i; }
SDL_34:106:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (checker != null) {     stop = checker.converged( iter, previous, current ); }  =>  
SDL_35:110:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (!stop) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } }  =>   if (true) {     if (checker != null) {         stop = checker.converged( iter, previous, current );     } }
SDL_36:107:org.apache.commons.math3.optim.PointValuePair_doOptimize(): stop = checker.converged( iter, previous, current );  =>  
SDL_37:109:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (checker != null) {     stop = checker.converged( iter, previous, current ); }  =>   if (true) {     stop = checker.converged( iter, previous, current ); }
SDL_38:111:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (goal == GoalType.MINIMIZE) {     return fVal < fX ? current : previous; } else {     return fVal > fX ? current : previous; }  =>  
SDL_39:117:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (stop) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } }  =>   if (true) {     if (goal == GoalType.MINIMIZE) {         return fVal < fX ? current : previous;     } else {         return fVal > fX ? current : previous;     } }
SDL_40:116:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (goal == GoalType.MINIMIZE) {     return fVal < fX ? current : previous; } else {     return fVal > fX ? current : previous; }  =>   if (true) {     return fVal < fX ? current : previous; } else {     return fVal > fX ? current : previous; }
SDL_41:121:org.apache.commons.math3.optim.PointValuePair_doOptimize(): d[i] = x[i] - x1[i]; x2[i] = 2 * x[i] - x1[i];  =>   x2[i] = 2 * x[i] - x1[i];
SDL_42:121:org.apache.commons.math3.optim.PointValuePair_doOptimize(): d[i] = x[i] - x1[i]; x2[i] = 2 * x[i] - x1[i];  =>   d[i] = x[i] - x1[i];
SDL_43:123:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; }  =>   for (int i = 0;; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; }
SDL_44:123:org.apache.commons.math3.optim.PointValuePair_doOptimize(): for (int i = 0; i < n; i++) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; }  =>   for (int i = 0; i < n;) {     d[i] = x[i] - x1[i];     x2[i] = 2 * x[i] - x1[i]; }
SDL_45:140:org.apache.commons.math3.optim.PointValuePair_doOptimize(): double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }  =>   double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }
SDL_46:140:org.apache.commons.math3.optim.PointValuePair_doOptimize(): double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }  =>   double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }
SDL_47:140:org.apache.commons.math3.optim.PointValuePair_doOptimize(): double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }  =>   double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }
SDL_48:131:org.apache.commons.math3.optim.PointValuePair_doOptimize(): double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }  =>   double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp;
SDL_49:142:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (fX > fX2) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }  =>   if (true) {     double t = 2 * (fX + fX2 - 2 * fVal);     double temp = fX - fVal - delta;     t *= temp * temp;     temp = fX - fX2;     t -= delta * temp * temp;     if (t < 0.0) {         final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );         fVal = optimum.getValue();         alphaMin = optimum.getPoint();         final double[][] result = newPointAndDirection( x, d, alphaMin );         x = result[0];         final int lastInd = n - 1;         direc[bigInd] = direc[lastInd];         direc[lastInd] = result[1];     } }
SDL_50:139:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];  =>   final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];
SDL_51:139:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];  =>   final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];
SDL_52:139:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];  =>   final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];
SDL_53:139:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];  =>   final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[lastInd] = result[1];
SDL_54:139:org.apache.commons.math3.optim.PointValuePair_doOptimize(): final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1];  =>   final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d ); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection( x, d, alphaMin ); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd];
SDL_55:141:org.apache.commons.math3.optim.PointValuePair_doOptimize(): if (t < 0.0) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }  =>   if (true) {     final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search( x, d );     fVal = optimum.getValue();     alphaMin = optimum.getPoint();     final double[][] result = newPointAndDirection( x, d, alphaMin );     x = result[0];     final int lastInd = n - 1;     direc[bigInd] = direc[lastInd];     direc[lastInd] = result[1]; }
SDL_56:154:double_newPointAndDirection(double,double,double): final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; } final double[][] result = new double[2][]; result[0] = nP; result[1] = nD; return result;  =>   final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; final double[][] result = new double[2][]; result[0] = nP; result[1] = nD; return result;
SDL_57:157:double_newPointAndDirection(double,double,double): final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; } final double[][] result = new double[2][]; result[0] = nP; result[1] = nD; return result;  =>   final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; } final double[][] result = new double[2][]; result[1] = nD; return result;
SDL_58:157:double_newPointAndDirection(double,double,double): final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; } final double[][] result = new double[2][]; result[0] = nP; result[1] = nD; return result;  =>   final int n = p.length; final double[] nP = new double[n]; final double[] nD = new double[n]; for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; } final double[][] result = new double[2][]; result[0] = nP; return result;
SDL_59:152:double_newPointAndDirection(double,double,double): nD[i] = d[i] * optimum; nP[i] = p[i] + nD[i];  =>   nP[i] = p[i] + nD[i];
SDL_60:152:double_newPointAndDirection(double,double,double): nD[i] = d[i] * optimum; nP[i] = p[i] + nD[i];  =>   nD[i] = d[i] * optimum;
SDL_61:154:double_newPointAndDirection(double,double,double): for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; }  =>   for (int i = 0;; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; }
SDL_62:154:double_newPointAndDirection(double,double,double): for (int i = 0; i < n; i++) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; }  =>   for (int i = 0; i < n;) {     nD[i] = d[i] * optimum;     nP[i] = p[i] + nD[i]; }
SDL_63:158:double_newPointAndDirection(double,double,double): return result;  =>   return 0;
SDL_64:190:org.apache.commons.math3.optim.univariate.UnivariatePointValuePair_search(double,double): final int n = p.length; final org.apache.commons.math3.analysis.UnivariateFunction f = new org.apache.commons.math3.analysis.UnivariateFunction(){     public  double value( double alpha )     {         final double[] x = new double[n];         for (int i = 0; i < n; i++) {             x[i] = p[i] + alpha * d[i];         }         final double obj = PowellOptimizer.this.computeObjectiveValue( x );         return obj;     } }; final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = PowellOptimizer.this.getGoalType(); bracket.search( f, goal, 0, 1 ); return optimize( new org.apache.commons.math3.optim.MaxEval( Integer.MAX_VALUE ), new org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction( f ), goal, new org.apache.commons.math3.optim.univariate.SearchInterval( bracket.getLo(), bracket.getHi(), bracket.getMid() ) );  =>   final int n = p.length; final org.apache.commons.math3.analysis.UnivariateFunction f = new org.apache.commons.math3.analysis.UnivariateFunction(){     public  double value( double alpha )     {         final double[] x = new double[n];         for (int i = 0; i < n; i++) {             x[i] = p[i] + alpha * d[i];         }         final double obj = PowellOptimizer.this.computeObjectiveValue( x );         return obj;     } }; final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = PowellOptimizer.this.getGoalType(); return optimize( new org.apache.commons.math3.optim.MaxEval( Integer.MAX_VALUE ), new org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction( f ), goal, new org.apache.commons.math3.optim.univariate.SearchInterval( bracket.getLo(), bracket.getHi(), bracket.getMid() ) );
SDL_65:197:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>  
SDL_66:198:void_checkParameters(): throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT );  =>  
SDL_67:200:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }
