AORB_1:70:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * residual => weight / residual
AORB_2:70:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * residual => weight % residual
AORB_3:70:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * residual => weight + residual
AORB_4:70:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * residual => weight - residual
AORB_5:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wr * grad[j] => wr / grad[j]
AORB_6:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wr * grad[j] => wr % grad[j]
AORB_7:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wr * grad[j] => wr + grad[j]
AORB_8:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wr * grad[j] => wr - grad[j]
AORB_9:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * grad[k] => weight / grad[k]
AORB_10:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * grad[k] => weight % grad[k]
AORB_11:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * grad[k] => weight + grad[k]
AORB_12:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight * grad[k] => weight - grad[k]
AORB_13:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wgk * grad[l] => wgk / grad[l]
AORB_14:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wgk * grad[l] => wgk % grad[l]
AORB_15:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wgk * grad[l] => wgk + grad[l]
AORB_16:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wgk * grad[l] => wgk - grad[l]
AOIU_1:47:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():targetValues.length => -targetValues.length
AOIU_2:49:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_3:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_4:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_5:51:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_6:51:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_7:54:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentPoint.length => -currentPoint.length
AOIU_8:64:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_9:65:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_10:65:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_11:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_12:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_13:67:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_14:68:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_15:69:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_16:70:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight => -weight
AOIU_17:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_18:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_19:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wr => -wr
AOIU_20:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_21:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_22:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_23:75:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_24:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weight => -weight
AOIU_25:76:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_26:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():l => -l
AOIU_27:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_28:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():wgk => -wgk
AOIU_29:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():l => -l
AOIU_30:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_31:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_32:87:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_33:93:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():iter => -iter
ROR_1:43:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checker == null  =>   checker != null
ROR_2:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i > nR
ROR_3:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i >= nR
ROR_4:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i <= nR
ROR_5:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i == nR
ROR_6:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i != nR
ROR_7:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   true
ROR_8:50:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   false
ROR_9:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i > nR
ROR_10:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i >= nR
ROR_11:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i <= nR
ROR_12:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i == nR
ROR_13:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i != nR
ROR_14:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   true
ROR_15:66:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   false
ROR_16:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j > nC
ROR_17:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j >= nC
ROR_18:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j <= nC
ROR_19:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j == nC
ROR_20:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j != nC
ROR_21:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   true
ROR_22:71:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   false
ROR_23:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k > nC
ROR_24:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k >= nC
ROR_25:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k <= nC
ROR_26:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k == nC
ROR_27:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k != nC
ROR_28:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   true
ROR_29:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   false
ROR_30:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   l > nC
ROR_31:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   l >= nC
ROR_32:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   l <= nC
ROR_33:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   l == nC
ROR_34:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   l != nC
ROR_35:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   true
ROR_36:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): l < nC  =>   false
ROR_37:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   i > nC
ROR_38:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   i >= nC
ROR_39:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   i <= nC
ROR_40:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   i == nC
ROR_41:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   i != nC
ROR_42:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   true
ROR_43:86:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nC  =>   false
ROR_44:92:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): previous != null  =>   previous == null
ROR_45:105:void_checkParameters(): getLowerBound() != null  =>   getLowerBound() == null
ROR_46:105:void_checkParameters(): getUpperBound() != null  =>   getUpperBound() == null
COR_1:105:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null && getUpperBound() != null
COR_2:105:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null ^ getUpperBound() != null
SDL_1:36:GaussNewtonOptimizer(boolean,org.apache.commons.math3.optim.ConvergenceChecker): this.useLU = useLU;  =>  
SDL_2:100:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();  =>   final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();
SDL_3:98:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();  =>   checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();
SDL_4:98:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();  =>   checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();
SDL_5:58:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();  =>   checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; throw new org.apache.commons.math3.exception.MathInternalError();
SDL_6:100:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } } throw new org.apache.commons.math3.exception.MathInternalError();  =>   checkParameters(); final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); } final double[] targetValues = getTarget(); final int nR = targetValues.length; final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight(); final double[] residualsWeights = new double[nR]; for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); } final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; org.apache.commons.math3.optim.PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } }
SDL_7:44:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): throw new org.apache.commons.math3.exception.NullArgumentException();  =>  
SDL_8:46:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (checker == null) {     throw new org.apache.commons.math3.exception.NullArgumentException(); }  =>   if (true) {     throw new org.apache.commons.math3.exception.NullArgumentException(); }
SDL_9:51:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): residualsWeights[i] = weightMatrix.getEntry( i, i );  =>  
SDL_10:53:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); }  =>   for (int i = 0;; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); }
SDL_11:53:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; i++) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); }  =>   for (int i = 0; i < nR;) {     residualsWeights[i] = weightMatrix.getEntry( i, i ); }
SDL_12:98:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }  =>   org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }
SDL_13:98:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }  =>   ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }
SDL_14:83:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }  =>   ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }
SDL_15:92:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); } if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }  =>   ++iter; org.apache.commons.math3.optim.PointVectorValuePair previous = current; final double[] currentObjective = computeObjectiveValue( currentPoint ); final double[] currentResiduals = computeResiduals( currentObjective ); final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); final double[] b = new double[nC]; final double[][] a = new double[nC][nC]; for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } } try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); }
SDL_16:100:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (boolean converged = false; !converged;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } }  =>   for (boolean converged = false;;) {     ++iter;     org.apache.commons.math3.optim.PointVectorValuePair previous = current;     final double[] currentObjective = computeObjectiveValue( currentPoint );     final double[] currentResiduals = computeResiduals( currentObjective );     final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian( currentPoint );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     final double[] b = new double[nC];     final double[][] a = new double[nC][nC];     for (int i = 0; i < nR; ++i) {         final double[] grad = weightedJacobian.getRow( i );         final double weight = residualsWeights[i];         final double residual = currentResiduals[i];         final double wr = weight * residual;         for (int j = 0; j < nC; ++j) {             b[j] += wr * grad[j];         }         for (int k = 0; k < nC; ++k) {             double[] ak = a[k];             double wgk = weight * grad[k];             for (int l = 0; l < nC; ++l) {                 ak[l] += wgk * grad[l];             }         }     }     try {         org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );         org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();         final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();         for (int i = 0; i < nC; ++i) {             currentPoint[i] += dX[i];         }     } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM );     }     if (previous != null) {         converged = checker.converged( iter, previous, current );         if (converged) {             setCost( computeCost( currentResiduals ) );             return current;         }     } }
SDL_17:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): final double[] grad = weightedJacobian.getRow( i ); final double weight = residualsWeights[i]; final double residual = currentResiduals[i]; final double wr = weight * residual; for (int j = 0; j < nC; ++j) {     b[j] += wr * grad[j]; } for (int k = 0; k < nC; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }  =>   final double[] grad = weightedJacobian.getRow( i ); final double weight = residualsWeights[i]; final double residual = currentResiduals[i]; final double wr = weight * residual; for (int k = 0; k < nC; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }
SDL_18:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): final double[] grad = weightedJacobian.getRow( i ); final double weight = residualsWeights[i]; final double residual = currentResiduals[i]; final double wr = weight * residual; for (int j = 0; j < nC; ++j) {     b[j] += wr * grad[j]; } for (int k = 0; k < nC; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }  =>   final double[] grad = weightedJacobian.getRow( i ); final double weight = residualsWeights[i]; final double residual = currentResiduals[i]; final double wr = weight * residual; for (int j = 0; j < nC; ++j) {     b[j] += wr * grad[j]; }
SDL_19:82:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } }  =>   for (int i = 0;; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } }
SDL_20:82:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; ++i) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } }  =>   for (int i = 0; i < nR;) {     final double[] grad = weightedJacobian.getRow( i );     final double weight = residualsWeights[i];     final double residual = currentResiduals[i];     final double wr = weight * residual;     for (int j = 0; j < nC; ++j) {         b[j] += wr * grad[j];     }     for (int k = 0; k < nC; ++k) {         double[] ak = a[k];         double wgk = weight * grad[k];         for (int l = 0; l < nC; ++l) {             ak[l] += wgk * grad[l];         }     } }
SDL_21:72:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): b[j] += wr * grad[j];  =>  
SDL_22:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < nC; ++j) {     b[j] += wr * grad[j]; }  =>   for (int j = 0;; ++j) {     b[j] += wr * grad[j]; }
SDL_23:74:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < nC; ++j) {     b[j] += wr * grad[j]; }  =>   for (int j = 0; j < nC;) {     b[j] += wr * grad[j]; }
SDL_24:77:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double[] ak = a[k]; double wgk = weight * grad[k]; for (int l = 0; l < nC; ++l) {     ak[l] += wgk * grad[l]; }  =>   double[] ak = a[k]; double wgk = weight * grad[k];
SDL_25:81:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }  =>   for (int k = 0;; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }
SDL_26:81:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }  =>   for (int k = 0; k < nC;) {     double[] ak = a[k];     double wgk = weight * grad[k];     for (int l = 0; l < nC; ++l) {         ak[l] += wgk * grad[l];     } }
SDL_27:78:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ak[l] += wgk * grad[l];  =>  
SDL_28:80:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int l = 0; l < nC; ++l) {     ak[l] += wgk * grad[l]; }  =>   for (int l = 0;; ++l) {     ak[l] += wgk * grad[l]; }
SDL_29:80:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int l = 0; l < nC; ++l) {     ak[l] += wgk * grad[l]; }  =>   for (int l = 0; l < nC;) {     ak[l] += wgk * grad[l]; }
SDL_30:87:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray();     for (int i = 0; i < nC; ++i) {         currentPoint[i] += dX[i];     } } catch ( org.apache.commons.math3.linear.SingularMatrixException e ) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ); }  =>   try {     org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix( a );     org.apache.commons.math3.linear.DecompositionSolver solver = useLU ? (new org.apache.commons.math3.linear.LUDecomposition( mA )).getSolver() : (new org.apache.commons.math3.linear.QRDecomposition( mA )).getSolver();     final double[] dX = solver.solve( new org.apache.commons.math3.linear.ArrayRealVector( b, false ) ).toArray(); }
SDL_31:87:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentPoint[i] += dX[i];  =>  
SDL_32:89:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nC; ++i) {     currentPoint[i] += dX[i]; }  =>   for (int i = 0;; ++i) {     currentPoint[i] += dX[i]; }
SDL_33:89:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nC; ++i) {     currentPoint[i] += dX[i]; }  =>   for (int i = 0; i < nC;) {     currentPoint[i] += dX[i]; }
SDL_34:97:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): converged = checker.converged( iter, previous, current ); if (converged) {     setCost( computeCost( currentResiduals ) );     return current; }  =>   if (converged) {     setCost( computeCost( currentResiduals ) );     return current; }
SDL_35:94:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): converged = checker.converged( iter, previous, current ); if (converged) {     setCost( computeCost( currentResiduals ) );     return current; }  =>   converged = checker.converged( iter, previous, current );
SDL_36:99:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (previous != null) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }  =>   if (true) {     converged = checker.converged( iter, previous, current );     if (converged) {         setCost( computeCost( currentResiduals ) );         return current;     } }
SDL_37:96:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): setCost( computeCost( currentResiduals ) ); return current;  =>   return current;
SDL_38:98:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (converged) {     setCost( computeCost( currentResiduals ) );     return current; }  =>   if (true) {     setCost( computeCost( currentResiduals ) );     return current; }
SDL_39:105:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>  
SDL_40:106:void_checkParameters(): throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT );  =>  
SDL_41:108:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }
