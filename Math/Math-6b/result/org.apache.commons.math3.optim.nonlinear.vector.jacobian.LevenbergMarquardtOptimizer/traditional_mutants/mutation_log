AORB_1:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk * currentPoint[k] => dk / currentPoint[k]
AORB_2:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk * currentPoint[k] => dk % currentPoint[k]
AORB_3:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk * currentPoint[k] => dk + currentPoint[k]
AORB_4:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk * currentPoint[k] => dk - currentPoint[k]
AORB_5:138:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xk * xk => xk / xk
AORB_6:138:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xk * xk => xk % xk
AORB_7:138:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xk * xk => xk + xk
AORB_8:138:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xk * xk => xk - xk
AORB_9:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor * xNorm => initialStepBoundFactor / xNorm
AORB_10:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor * xNorm => initialStepBoundFactor % xNorm
AORB_11:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor * xNorm => initialStepBoundFactor + xNorm
AORB_12:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor * xNorm => initialStepBoundFactor - xNorm
AORB_13:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * qtf[i] => weightedJacobian[i][pj] / qtf[i]
AORB_14:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * qtf[i] => weightedJacobian[i][pj] % qtf[i]
AORB_15:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * qtf[i] => weightedJacobian[i][pj] + qtf[i]
AORB_16:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * qtf[i] => weightedJacobian[i][pj] - qtf[i]
AORB_17:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * currentCost => s / currentCost
AORB_18:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * currentCost => s % currentCost
AORB_19:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * currentCost => s + currentCost
AORB_20:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * currentCost => s - currentCost
AORB_21:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():FastMath.abs( sum ) / (s * currentCost) => FastMath.abs( sum ) * (s * currentCost)
AORB_22:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():FastMath.abs( sum ) / (s * currentCost) => FastMath.abs( sum ) % (s * currentCost)
AORB_23:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():FastMath.abs( sum ) / (s * currentCost) => FastMath.abs( sum ) + s * currentCost
AORB_24:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():FastMath.abs( sum ) / (s * currentCost) => FastMath.abs( sum ) - s * currentCost
AORB_25:182:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():oldX[pj] + lmDir[pj] => oldX[pj] * lmDir[pj]
AORB_26:182:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():oldX[pj] + lmDir[pj] => oldX[pj] / lmDir[pj]
AORB_27:182:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():oldX[pj] + lmDir[pj] => oldX[pj] % lmDir[pj]
AORB_28:182:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():oldX[pj] + lmDir[pj] => oldX[pj] - lmDir[pj]
AORB_29:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[pj] * lmDir[pj] => diag[pj] / lmDir[pj]
AORB_30:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[pj] * lmDir[pj] => diag[pj] % lmDir[pj]
AORB_31:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[pj] * lmDir[pj] => diag[pj] + lmDir[pj]
AORB_32:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[pj] * lmDir[pj] => diag[pj] - lmDir[pj]
AORB_33:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * s => s / s
AORB_34:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * s => s % s
AORB_35:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * s => s + s
AORB_36:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s * s => s - s
AORB_37:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 / currentCost
AORB_38:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 % currentCost
AORB_39:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 + currentCost
AORB_40:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 - currentCost
AORB_41:196:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost / previousCost => currentCost * previousCost
AORB_42:196:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost / previousCost => currentCost % previousCost
AORB_43:196:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost / previousCost => currentCost + previousCost
AORB_44:196:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost / previousCost => currentCost - previousCost
AORB_45:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():r * r => r / r
AORB_46:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():r * r => r % r
AORB_47:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():r * r => r + r
AORB_48:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():r * r => r - r
AORB_49:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():1.0 - r * r => 1.0 * (r * r)
AORB_50:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():1.0 - r * r => 1.0 / (r * r)
AORB_51:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():1.0 - r * r => 1.0 % (r * r)
AORB_52:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():1.0 - r * r => 1.0 + r * r
AORB_53:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * dirJ => weightedJacobian[i][pj] / dirJ
AORB_54:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * dirJ => weightedJacobian[i][pj] % dirJ
AORB_55:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * dirJ => weightedJacobian[i][pj] + dirJ
AORB_56:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():weightedJacobian[i][pj] * dirJ => weightedJacobian[i][pj] - dirJ
AORB_57:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():work1[j] * work1[j] => work1[j] / work1[j]
AORB_58:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():work1[j] * work1[j] => work1[j] % work1[j]
AORB_59:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():work1[j] * work1[j] => work1[j] + work1[j]
AORB_60:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():work1[j] * work1[j] => work1[j] - work1[j]
AORB_61:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost * previousCost => previousCost / previousCost
AORB_62:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost * previousCost => previousCost % previousCost
AORB_63:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost * previousCost => previousCost + previousCost
AORB_64:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost * previousCost => previousCost - previousCost
AORB_65:212:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 / pc2 => coeff1 * pc2
AORB_66:212:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 / pc2 => coeff1 % pc2
AORB_67:212:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 / pc2 => coeff1 + pc2
AORB_68:212:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 / pc2 => coeff1 - pc2
AORB_69:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm => lmPar / lmNorm
AORB_70:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm => lmPar % lmNorm
AORB_71:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm => lmPar + lmNorm
AORB_72:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm => lmPar - lmNorm
AORB_73:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm => lmPar * lmNorm / lmNorm
AORB_74:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm => lmPar * lmNorm % lmNorm
AORB_75:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm => lmPar * lmNorm + lmNorm
AORB_76:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm => lmPar * lmNorm - lmNorm
AORB_77:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm / pc2 => lmPar * lmNorm * lmNorm * pc2
AORB_78:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm / pc2 => lmPar * lmNorm * lmNorm % pc2
AORB_79:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm / pc2 => lmPar * lmNorm * lmNorm + pc2
AORB_80:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar * lmNorm * lmNorm / pc2 => lmPar * lmNorm * lmNorm - pc2
AORB_81:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * coeff2 => 2 / coeff2
AORB_82:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * coeff2 => 2 % coeff2
AORB_83:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * coeff2 => 2 + coeff2
AORB_84:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * coeff2 => 2 - coeff2
AORB_85:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + 2 * coeff2 => coeff1 * (2 * coeff2)
AORB_86:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + 2 * coeff2 => coeff1 / (2 * coeff2)
AORB_87:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + 2 * coeff2 => coeff1 % (2 * coeff2)
AORB_88:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + 2 * coeff2 => coeff1 - 2 * coeff2
AORB_89:215:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + coeff2 => coeff1 * coeff2
AORB_90:215:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + coeff2 => coeff1 / coeff2
AORB_91:215:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + coeff2 => coeff1 % coeff2
AORB_92:215:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 + coeff2 => coeff1 - coeff2
AORB_93:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed / preRed => actRed * preRed
AORB_94:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed / preRed => actRed % preRed
AORB_95:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed / preRed => actRed + preRed
AORB_96:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed / preRed => actRed - preRed
AORB_97:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer => 0.5 / dirDer
AORB_98:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer => 0.5 % dirDer
AORB_99:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer => 0.5 + dirDer
AORB_100:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer => 0.5 - dirDer
AORB_101:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * actRed => 0.5 / actRed
AORB_102:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * actRed => 0.5 % actRed
AORB_103:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * actRed => 0.5 + actRed
AORB_104:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * actRed => 0.5 - actRed
AORB_105:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer + 0.5 * actRed => dirDer * (0.5 * actRed)
AORB_106:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer + 0.5 * actRed => dirDer / (0.5 * actRed)
AORB_107:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer + 0.5 * actRed => dirDer % (0.5 * actRed)
AORB_108:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer + 0.5 * actRed => dirDer - 0.5 * actRed
AORB_109:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer / (dirDer + 0.5 * actRed) => 0.5 * dirDer * (dirDer + 0.5 * actRed)
AORB_110:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer / (dirDer + 0.5 * actRed) => 0.5 * dirDer % (dirDer + 0.5 * actRed)
AORB_111:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer / (dirDer + 0.5 * actRed) => 0.5 * dirDer + (dirDer + 0.5 * actRed)
AORB_112:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.5 * dirDer / (dirDer + 0.5 * actRed) => 0.5 * dirDer - (dirDer + 0.5 * actRed)
AORB_113:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 / currentCost
AORB_114:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 % currentCost
AORB_115:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 + currentCost
AORB_116:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():0.1 * currentCost => 0.1 - currentCost
AORB_117:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():10.0 * lmNorm => 10.0 / lmNorm
AORB_118:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():10.0 * lmNorm => 10.0 % lmNorm
AORB_119:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():10.0 * lmNorm => 10.0 + lmNorm
AORB_120:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():10.0 * lmNorm => 10.0 - lmNorm
AORB_121:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp * FastMath.min( delta, 10.0 * lmNorm ) => tmp / FastMath.min( delta, 10.0 * lmNorm )
AORB_122:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp * FastMath.min( delta, 10.0 * lmNorm ) => tmp % FastMath.min( delta, 10.0 * lmNorm )
AORB_123:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp * FastMath.min( delta, 10.0 * lmNorm ) => tmp + FastMath.min( delta, 10.0 * lmNorm )
AORB_124:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp * FastMath.min( delta, 10.0 * lmNorm ) => tmp - FastMath.min( delta, 10.0 * lmNorm )
AORB_125:226:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * lmNorm => 2 / lmNorm
AORB_126:226:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * lmNorm => 2 % lmNorm
AORB_127:226:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * lmNorm => 2 + lmNorm
AORB_128:226:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2 * lmNorm => 2 - lmNorm
AORB_129:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[k] * currentPoint[k] => diag[k] / currentPoint[k]
AORB_130:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[k] * currentPoint[k] => diag[k] % currentPoint[k]
AORB_131:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[k] * currentPoint[k] => diag[k] + currentPoint[k]
AORB_132:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():diag[k] * currentPoint[k] => diag[k] - currentPoint[k]
AORB_133:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xK * xK => xK / xK
AORB_134:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xK * xK => xK % xK
AORB_135:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xK * xK => xK + xK
AORB_136:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xK * xK => xK - xK
AORB_137:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():parRelativeTolerance * xNorm => parRelativeTolerance / xNorm
AORB_138:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():parRelativeTolerance * xNorm => parRelativeTolerance % xNorm
AORB_139:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():parRelativeTolerance * xNorm => parRelativeTolerance + xNorm
AORB_140:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():parRelativeTolerance * xNorm => parRelativeTolerance - xNorm
AORB_141:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2.2204e-16 * xNorm => 2.2204e-16 / xNorm
AORB_142:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2.2204e-16 * xNorm => 2.2204e-16 % xNorm
AORB_143:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2.2204e-16 * xNorm => 2.2204e-16 + xNorm
AORB_144:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():2.2204e-16 * xNorm => 2.2204e-16 - xNorm
AORB_145:286:void_determineLMParameter(double,double,double,double,double,double):rank - 1 => rank * 1
AORB_146:286:void_determineLMParameter(double,double,double,double,double,double):rank - 1 => rank / 1
AORB_147:286:void_determineLMParameter(double,double,double,double,double,double):rank - 1 => rank % 1
AORB_148:286:void_determineLMParameter(double,double,double,double,double,double):rank - 1 => rank + 1
AORB_149:288:void_determineLMParameter(double,double,double,double,double,double):lmDir[pk] / diagR[pk] => lmDir[pk] * diagR[pk]
AORB_150:288:void_determineLMParameter(double,double,double,double,double,double):lmDir[pk] / diagR[pk] => lmDir[pk] % diagR[pk]
AORB_151:288:void_determineLMParameter(double,double,double,double,double,double):lmDir[pk] / diagR[pk] => lmDir[pk] + diagR[pk]
AORB_152:288:void_determineLMParameter(double,double,double,double,double,double):lmDir[pk] / diagR[pk] => lmDir[pk] - diagR[pk]
AORB_153:290:void_determineLMParameter(double,double,double,double,double,double):ypk * weightedJacobian[i][pk] => ypk / weightedJacobian[i][pk]
AORB_154:290:void_determineLMParameter(double,double,double,double,double,double):ypk * weightedJacobian[i][pk] => ypk % weightedJacobian[i][pk]
AORB_155:290:void_determineLMParameter(double,double,double,double,double,double):ypk * weightedJacobian[i][pk] => ypk + weightedJacobian[i][pk]
AORB_156:290:void_determineLMParameter(double,double,double,double,double,double):ypk * weightedJacobian[i][pk] => ypk - weightedJacobian[i][pk]
AORB_157:297:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] / lmDir[pj]
AORB_158:297:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] % lmDir[pj]
AORB_159:297:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] + lmDir[pj]
AORB_160:297:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] - lmDir[pj]
AORB_161:299:void_determineLMParameter(double,double,double,double,double,double):s * s => s / s
AORB_162:299:void_determineLMParameter(double,double,double,double,double,double):s * s => s % s
AORB_163:299:void_determineLMParameter(double,double,double,double,double,double):s * s => s + s
AORB_164:299:void_determineLMParameter(double,double,double,double,double,double):s * s => s - s
AORB_165:302:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm * delta
AORB_166:302:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm / delta
AORB_167:302:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm % delta
AORB_168:302:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm + delta
AORB_169:303:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 / delta
AORB_170:303:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 % delta
AORB_171:303:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 + delta
AORB_172:303:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 - delta
AORB_173:312:void_determineLMParameter(double,double,double,double,double,double):diag[pj] / dxNorm => diag[pj] * dxNorm
AORB_174:312:void_determineLMParameter(double,double,double,double,double,double):diag[pj] / dxNorm => diag[pj] % dxNorm
AORB_175:312:void_determineLMParameter(double,double,double,double,double,double):diag[pj] / dxNorm => diag[pj] + dxNorm
AORB_176:312:void_determineLMParameter(double,double,double,double,double,double):diag[pj] / dxNorm => diag[pj] - dxNorm
AORB_177:319:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * work1[permutation[i]] => weightedJacobian[i][pj] / work1[permutation[i]]
AORB_178:319:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * work1[permutation[i]] => weightedJacobian[i][pj] % work1[permutation[i]]
AORB_179:319:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * work1[permutation[i]] => weightedJacobian[i][pj] + work1[permutation[i]]
AORB_180:319:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * work1[permutation[i]] => weightedJacobian[i][pj] - work1[permutation[i]]
AORB_181:321:void_determineLMParameter(double,double,double,double,double,double):work1[pj] - sum => work1[pj] * sum
AORB_182:321:void_determineLMParameter(double,double,double,double,double,double):work1[pj] - sum => work1[pj] / sum
AORB_183:321:void_determineLMParameter(double,double,double,double,double,double):work1[pj] - sum => work1[pj] % sum
AORB_184:321:void_determineLMParameter(double,double,double,double,double,double):work1[pj] - sum => work1[pj] + sum
AORB_185:321:void_determineLMParameter(double,double,double,double,double,double):(work1[pj] - sum) / diagR[pj] => (work1[pj] - sum) * diagR[pj]
AORB_186:321:void_determineLMParameter(double,double,double,double,double,double):(work1[pj] - sum) / diagR[pj] => (work1[pj] - sum) % diagR[pj]
AORB_187:321:void_determineLMParameter(double,double,double,double,double,double):(work1[pj] - sum) / diagR[pj] => work1[pj] - sum + diagR[pj]
AORB_188:321:void_determineLMParameter(double,double,double,double,double,double):(work1[pj] - sum) / diagR[pj] => work1[pj] - sum - diagR[pj]
AORB_189:323:void_determineLMParameter(double,double,double,double,double,double):s * s => s / s
AORB_190:323:void_determineLMParameter(double,double,double,double,double,double):s * s => s % s
AORB_191:323:void_determineLMParameter(double,double,double,double,double,double):s * s => s + s
AORB_192:323:void_determineLMParameter(double,double,double,double,double,double):s * s => s - s
AORB_193:325:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta / sum2
AORB_194:325:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta % sum2
AORB_195:325:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta + sum2
AORB_196:325:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta - sum2
AORB_197:325:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp * (delta * sum2)
AORB_198:325:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp % (delta * sum2)
AORB_199:325:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp + delta * sum2
AORB_200:325:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp - delta * sum2
AORB_201:332:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * qy[i] => weightedJacobian[i][pj] / qy[i]
AORB_202:332:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * qy[i] => weightedJacobian[i][pj] % qy[i]
AORB_203:332:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * qy[i] => weightedJacobian[i][pj] + qy[i]
AORB_204:332:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * qy[i] => weightedJacobian[i][pj] - qy[i]
AORB_205:335:void_determineLMParameter(double,double,double,double,double,double):sum * sum => sum / sum
AORB_206:335:void_determineLMParameter(double,double,double,double,double,double):sum * sum => sum % sum
AORB_207:335:void_determineLMParameter(double,double,double,double,double,double):sum * sum => sum + sum
AORB_208:335:void_determineLMParameter(double,double,double,double,double,double):sum * sum => sum - sum
AORB_209:338:void_determineLMParameter(double,double,double,double,double,double):gNorm / delta => gNorm * delta
AORB_210:338:void_determineLMParameter(double,double,double,double,double,double):gNorm / delta => gNorm % delta
AORB_211:338:void_determineLMParameter(double,double,double,double,double,double):gNorm / delta => gNorm + delta
AORB_212:338:void_determineLMParameter(double,double,double,double,double,double):gNorm / delta => gNorm - delta
AORB_213:340:void_determineLMParameter(double,double,double,double,double,double):2.2251e-308 / FastMath.min( delta, 0.1 ) => 2.2251e-308 * FastMath.min( delta, 0.1 )
AORB_214:340:void_determineLMParameter(double,double,double,double,double,double):2.2251e-308 / FastMath.min( delta, 0.1 ) => 2.2251e-308 % FastMath.min( delta, 0.1 )
AORB_215:340:void_determineLMParameter(double,double,double,double,double,double):2.2251e-308 / FastMath.min( delta, 0.1 ) => 2.2251e-308 + FastMath.min( delta, 0.1 )
AORB_216:340:void_determineLMParameter(double,double,double,double,double,double):2.2251e-308 / FastMath.min( delta, 0.1 ) => 2.2251e-308 - FastMath.min( delta, 0.1 )
AORB_217:344:void_determineLMParameter(double,double,double,double,double,double):gNorm / dxNorm => gNorm * dxNorm
AORB_218:344:void_determineLMParameter(double,double,double,double,double,double):gNorm / dxNorm => gNorm % dxNorm
AORB_219:344:void_determineLMParameter(double,double,double,double,double,double):gNorm / dxNorm => gNorm + dxNorm
AORB_220:344:void_determineLMParameter(double,double,double,double,double,double):gNorm / dxNorm => gNorm - dxNorm
AORB_221:348:void_determineLMParameter(double,double,double,double,double,double):0.001 * paru => 0.001 / paru
AORB_222:348:void_determineLMParameter(double,double,double,double,double,double):0.001 * paru => 0.001 % paru
AORB_223:348:void_determineLMParameter(double,double,double,double,double,double):0.001 * paru => 0.001 + paru
AORB_224:348:void_determineLMParameter(double,double,double,double,double,double):0.001 * paru => 0.001 - paru
AORB_225:353:void_determineLMParameter(double,double,double,double,double,double):sPar * diag[pj] => sPar / diag[pj]
AORB_226:353:void_determineLMParameter(double,double,double,double,double,double):sPar * diag[pj] => sPar % diag[pj]
AORB_227:353:void_determineLMParameter(double,double,double,double,double,double):sPar * diag[pj] => sPar + diag[pj]
AORB_228:353:void_determineLMParameter(double,double,double,double,double,double):sPar * diag[pj] => sPar - diag[pj]
AORB_229:359:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] / lmDir[pj]
AORB_230:359:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] % lmDir[pj]
AORB_231:359:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] + lmDir[pj]
AORB_232:359:void_determineLMParameter(double,double,double,double,double,double):diag[pj] * lmDir[pj] => diag[pj] - lmDir[pj]
AORB_233:361:void_determineLMParameter(double,double,double,double,double,double):s * s => s / s
AORB_234:361:void_determineLMParameter(double,double,double,double,double,double):s * s => s % s
AORB_235:361:void_determineLMParameter(double,double,double,double,double,double):s * s => s + s
AORB_236:361:void_determineLMParameter(double,double,double,double,double,double):s * s => s - s
AORB_237:365:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm * delta
AORB_238:365:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm / delta
AORB_239:365:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm % delta
AORB_240:365:void_determineLMParameter(double,double,double,double,double,double):dxNorm - delta => dxNorm + delta
AORB_241:366:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 / delta
AORB_242:366:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 % delta
AORB_243:366:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 + delta
AORB_244:366:void_determineLMParameter(double,double,double,double,double,double):0.1 * delta => 0.1 - delta
AORB_245:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] => work3[pj] / diag[pj]
AORB_246:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] => work3[pj] % diag[pj]
AORB_247:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] => work3[pj] + diag[pj]
AORB_248:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] => work3[pj] - diag[pj]
AORB_249:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] / dxNorm => work3[pj] * diag[pj] * dxNorm
AORB_250:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] / dxNorm => work3[pj] * diag[pj] % dxNorm
AORB_251:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] / dxNorm => work3[pj] * diag[pj] + dxNorm
AORB_252:371:void_determineLMParameter(double,double,double,double,double,double):work3[pj] * diag[pj] / dxNorm => work3[pj] * diag[pj] - dxNorm
AORB_253:377:void_determineLMParameter(double,double,double,double,double,double):j + 1 => j * 1
AORB_254:377:void_determineLMParameter(double,double,double,double,double,double):j + 1 => j / 1
AORB_255:377:void_determineLMParameter(double,double,double,double,double,double):j + 1 => j % 1
AORB_256:377:void_determineLMParameter(double,double,double,double,double,double):j + 1 => j - 1
AORB_257:378:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * tmp => weightedJacobian[i][pj] / tmp
AORB_258:378:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * tmp => weightedJacobian[i][pj] % tmp
AORB_259:378:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * tmp => weightedJacobian[i][pj] + tmp
AORB_260:378:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[i][pj] * tmp => weightedJacobian[i][pj] - tmp
AORB_261:384:void_determineLMParameter(double,double,double,double,double,double):s * s => s / s
AORB_262:384:void_determineLMParameter(double,double,double,double,double,double):s * s => s % s
AORB_263:384:void_determineLMParameter(double,double,double,double,double,double):s * s => s + s
AORB_264:384:void_determineLMParameter(double,double,double,double,double,double):s * s => s - s
AORB_265:386:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta / sum2
AORB_266:386:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta % sum2
AORB_267:386:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta + sum2
AORB_268:386:void_determineLMParameter(double,double,double,double,double,double):delta * sum2 => delta - sum2
AORB_269:386:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp * (delta * sum2)
AORB_270:386:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp % (delta * sum2)
AORB_271:386:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp + delta * sum2
AORB_272:386:void_determineLMParameter(double,double,double,double,double,double):fp / (delta * sum2) => fp - delta * sum2
AORB_273:394:void_determineLMParameter(double,double,double,double,double,double):lmPar + correction => lmPar * correction
AORB_274:394:void_determineLMParameter(double,double,double,double,double,double):lmPar + correction => lmPar / correction
AORB_275:394:void_determineLMParameter(double,double,double,double,double,double):lmPar + correction => lmPar % correction
AORB_276:394:void_determineLMParameter(double,double,double,double,double,double):lmPar + correction => lmPar - correction
AORB_277:402:void_determineLMDirection(double,double,double,double):j + 1 => j * 1
AORB_278:402:void_determineLMDirection(double,double,double,double):j + 1 => j / 1
AORB_279:402:void_determineLMDirection(double,double,double,double):j + 1 => j % 1
AORB_280:402:void_determineLMDirection(double,double,double,double):j + 1 => j - 1
AORB_281:412:void_determineLMDirection(double,double,double,double):j + 1 => j * 1
AORB_282:412:void_determineLMDirection(double,double,double,double):j + 1 => j / 1
AORB_283:412:void_determineLMDirection(double,double,double,double):j + 1 => j % 1
AORB_284:412:void_determineLMDirection(double,double,double,double):j + 1 => j - 1
AORB_285:423:void_determineLMDirection(double,double,double,double):rkk / lmDiag[k] => rkk * lmDiag[k]
AORB_286:423:void_determineLMDirection(double,double,double,double):rkk / lmDiag[k] => rkk % lmDiag[k]
AORB_287:423:void_determineLMDirection(double,double,double,double):rkk / lmDiag[k] => rkk + lmDiag[k]
AORB_288:423:void_determineLMDirection(double,double,double,double):rkk / lmDiag[k] => rkk - lmDiag[k]
AORB_289:424:void_determineLMDirection(double,double,double,double):cotan * cotan => cotan / cotan
AORB_290:424:void_determineLMDirection(double,double,double,double):cotan * cotan => cotan % cotan
AORB_291:424:void_determineLMDirection(double,double,double,double):cotan * cotan => cotan + cotan
AORB_292:424:void_determineLMDirection(double,double,double,double):cotan * cotan => cotan - cotan
AORB_293:424:void_determineLMDirection(double,double,double,double):1.0 + cotan * cotan => 1.0 * (cotan * cotan)
AORB_294:424:void_determineLMDirection(double,double,double,double):1.0 + cotan * cotan => 1.0 / (cotan * cotan)
AORB_295:424:void_determineLMDirection(double,double,double,double):1.0 + cotan * cotan => 1.0 % (cotan * cotan)
AORB_296:424:void_determineLMDirection(double,double,double,double):1.0 + cotan * cotan => 1.0 - cotan * cotan
AORB_297:424:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + cotan * cotan ) => 1.0 * FastMath.sqrt( 1.0 + cotan * cotan )
AORB_298:424:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + cotan * cotan ) => 1.0 % FastMath.sqrt( 1.0 + cotan * cotan )
AORB_299:424:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + cotan * cotan ) => 1.0 + FastMath.sqrt( 1.0 + cotan * cotan )
AORB_300:424:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + cotan * cotan ) => 1.0 - FastMath.sqrt( 1.0 + cotan * cotan )
AORB_301:425:void_determineLMDirection(double,double,double,double):sin * cotan => sin / cotan
AORB_302:425:void_determineLMDirection(double,double,double,double):sin * cotan => sin % cotan
AORB_303:425:void_determineLMDirection(double,double,double,double):sin * cotan => sin + cotan
AORB_304:425:void_determineLMDirection(double,double,double,double):sin * cotan => sin - cotan
AORB_305:427:void_determineLMDirection(double,double,double,double):lmDiag[k] / rkk => lmDiag[k] * rkk
AORB_306:427:void_determineLMDirection(double,double,double,double):lmDiag[k] / rkk => lmDiag[k] % rkk
AORB_307:427:void_determineLMDirection(double,double,double,double):lmDiag[k] / rkk => lmDiag[k] + rkk
AORB_308:427:void_determineLMDirection(double,double,double,double):lmDiag[k] / rkk => lmDiag[k] - rkk
AORB_309:428:void_determineLMDirection(double,double,double,double):tan * tan => tan / tan
AORB_310:428:void_determineLMDirection(double,double,double,double):tan * tan => tan % tan
AORB_311:428:void_determineLMDirection(double,double,double,double):tan * tan => tan + tan
AORB_312:428:void_determineLMDirection(double,double,double,double):tan * tan => tan - tan
AORB_313:428:void_determineLMDirection(double,double,double,double):1.0 + tan * tan => 1.0 * (tan * tan)
AORB_314:428:void_determineLMDirection(double,double,double,double):1.0 + tan * tan => 1.0 / (tan * tan)
AORB_315:428:void_determineLMDirection(double,double,double,double):1.0 + tan * tan => 1.0 % (tan * tan)
AORB_316:428:void_determineLMDirection(double,double,double,double):1.0 + tan * tan => 1.0 - tan * tan
AORB_317:428:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + tan * tan ) => 1.0 * FastMath.sqrt( 1.0 + tan * tan )
AORB_318:428:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + tan * tan ) => 1.0 % FastMath.sqrt( 1.0 + tan * tan )
AORB_319:428:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + tan * tan ) => 1.0 + FastMath.sqrt( 1.0 + tan * tan )
AORB_320:428:void_determineLMDirection(double,double,double,double):1.0 / FastMath.sqrt( 1.0 + tan * tan ) => 1.0 - FastMath.sqrt( 1.0 + tan * tan )
AORB_321:429:void_determineLMDirection(double,double,double,double):cos * tan => cos / tan
AORB_322:429:void_determineLMDirection(double,double,double,double):cos * tan => cos % tan
AORB_323:429:void_determineLMDirection(double,double,double,double):cos * tan => cos + tan
AORB_324:429:void_determineLMDirection(double,double,double,double):cos * tan => cos - tan
AORB_325:431:void_determineLMDirection(double,double,double,double):cos * rkk => cos / rkk
AORB_326:431:void_determineLMDirection(double,double,double,double):cos * rkk => cos % rkk
AORB_327:431:void_determineLMDirection(double,double,double,double):cos * rkk => cos + rkk
AORB_328:431:void_determineLMDirection(double,double,double,double):cos * rkk => cos - rkk
AORB_329:431:void_determineLMDirection(double,double,double,double):sin * lmDiag[k] => sin / lmDiag[k]
AORB_330:431:void_determineLMDirection(double,double,double,double):sin * lmDiag[k] => sin % lmDiag[k]
AORB_331:431:void_determineLMDirection(double,double,double,double):sin * lmDiag[k] => sin + lmDiag[k]
AORB_332:431:void_determineLMDirection(double,double,double,double):sin * lmDiag[k] => sin - lmDiag[k]
AORB_333:431:void_determineLMDirection(double,double,double,double):cos * rkk + sin * lmDiag[k] => cos * rkk * (sin * lmDiag[k])
AORB_334:431:void_determineLMDirection(double,double,double,double):cos * rkk + sin * lmDiag[k] => cos * rkk / (sin * lmDiag[k])
AORB_335:431:void_determineLMDirection(double,double,double,double):cos * rkk + sin * lmDiag[k] => cos * rkk % (sin * lmDiag[k])
AORB_336:431:void_determineLMDirection(double,double,double,double):cos * rkk + sin * lmDiag[k] => cos * rkk - sin * lmDiag[k]
AORB_337:432:void_determineLMDirection(double,double,double,double):cos * work[k] => cos / work[k]
AORB_338:432:void_determineLMDirection(double,double,double,double):cos * work[k] => cos % work[k]
AORB_339:432:void_determineLMDirection(double,double,double,double):cos * work[k] => cos + work[k]
AORB_340:432:void_determineLMDirection(double,double,double,double):cos * work[k] => cos - work[k]
AORB_341:432:void_determineLMDirection(double,double,double,double):sin * qtbpj => sin / qtbpj
AORB_342:432:void_determineLMDirection(double,double,double,double):sin * qtbpj => sin % qtbpj
AORB_343:432:void_determineLMDirection(double,double,double,double):sin * qtbpj => sin + qtbpj
AORB_344:432:void_determineLMDirection(double,double,double,double):sin * qtbpj => sin - qtbpj
AORB_345:432:void_determineLMDirection(double,double,double,double):cos * work[k] + sin * qtbpj => cos * work[k] * (sin * qtbpj)
AORB_346:432:void_determineLMDirection(double,double,double,double):cos * work[k] + sin * qtbpj => cos * work[k] / (sin * qtbpj)
AORB_347:432:void_determineLMDirection(double,double,double,double):cos * work[k] + sin * qtbpj => cos * work[k] % (sin * qtbpj)
AORB_348:432:void_determineLMDirection(double,double,double,double):cos * work[k] + sin * qtbpj => cos * work[k] - sin * qtbpj
AORB_349:433:void_determineLMDirection(double,double,double,double):-sin * work[k] => -sin / work[k]
AORB_350:433:void_determineLMDirection(double,double,double,double):-sin * work[k] => -sin % work[k]
AORB_351:433:void_determineLMDirection(double,double,double,double):-sin * work[k] => -sin + work[k]
AORB_352:433:void_determineLMDirection(double,double,double,double):-sin * work[k] => -sin - work[k]
AORB_353:433:void_determineLMDirection(double,double,double,double):cos * qtbpj => cos / qtbpj
AORB_354:433:void_determineLMDirection(double,double,double,double):cos * qtbpj => cos % qtbpj
AORB_355:433:void_determineLMDirection(double,double,double,double):cos * qtbpj => cos + qtbpj
AORB_356:433:void_determineLMDirection(double,double,double,double):cos * qtbpj => cos - qtbpj
AORB_357:433:void_determineLMDirection(double,double,double,double):-sin * work[k] + cos * qtbpj => -sin * work[k] * (cos * qtbpj)
AORB_358:433:void_determineLMDirection(double,double,double,double):-sin * work[k] + cos * qtbpj => -sin * work[k] / (cos * qtbpj)
AORB_359:433:void_determineLMDirection(double,double,double,double):-sin * work[k] + cos * qtbpj => -sin * work[k] % (cos * qtbpj)
AORB_360:433:void_determineLMDirection(double,double,double,double):-sin * work[k] + cos * qtbpj => -sin * work[k] - cos * qtbpj
AORB_361:435:void_determineLMDirection(double,double,double,double):k + 1 => k * 1
AORB_362:435:void_determineLMDirection(double,double,double,double):k + 1 => k / 1
AORB_363:435:void_determineLMDirection(double,double,double,double):k + 1 => k % 1
AORB_364:435:void_determineLMDirection(double,double,double,double):k + 1 => k - 1
AORB_365:437:void_determineLMDirection(double,double,double,double):cos * rik => cos / rik
AORB_366:437:void_determineLMDirection(double,double,double,double):cos * rik => cos % rik
AORB_367:437:void_determineLMDirection(double,double,double,double):cos * rik => cos + rik
AORB_368:437:void_determineLMDirection(double,double,double,double):cos * rik => cos - rik
AORB_369:437:void_determineLMDirection(double,double,double,double):sin * lmDiag[i] => sin / lmDiag[i]
AORB_370:437:void_determineLMDirection(double,double,double,double):sin * lmDiag[i] => sin % lmDiag[i]
AORB_371:437:void_determineLMDirection(double,double,double,double):sin * lmDiag[i] => sin + lmDiag[i]
AORB_372:437:void_determineLMDirection(double,double,double,double):sin * lmDiag[i] => sin - lmDiag[i]
AORB_373:437:void_determineLMDirection(double,double,double,double):cos * rik + sin * lmDiag[i] => cos * rik * (sin * lmDiag[i])
AORB_374:437:void_determineLMDirection(double,double,double,double):cos * rik + sin * lmDiag[i] => cos * rik / (sin * lmDiag[i])
AORB_375:437:void_determineLMDirection(double,double,double,double):cos * rik + sin * lmDiag[i] => cos * rik % (sin * lmDiag[i])
AORB_376:437:void_determineLMDirection(double,double,double,double):cos * rik + sin * lmDiag[i] => cos * rik - sin * lmDiag[i]
AORB_377:438:void_determineLMDirection(double,double,double,double):-sin * rik => -sin / rik
AORB_378:438:void_determineLMDirection(double,double,double,double):-sin * rik => -sin % rik
AORB_379:438:void_determineLMDirection(double,double,double,double):-sin * rik => -sin + rik
AORB_380:438:void_determineLMDirection(double,double,double,double):-sin * rik => -sin - rik
AORB_381:438:void_determineLMDirection(double,double,double,double):cos * lmDiag[i] => cos / lmDiag[i]
AORB_382:438:void_determineLMDirection(double,double,double,double):cos * lmDiag[i] => cos % lmDiag[i]
AORB_383:438:void_determineLMDirection(double,double,double,double):cos * lmDiag[i] => cos + lmDiag[i]
AORB_384:438:void_determineLMDirection(double,double,double,double):cos * lmDiag[i] => cos - lmDiag[i]
AORB_385:438:void_determineLMDirection(double,double,double,double):-sin * rik + cos * lmDiag[i] => -sin * rik * (cos * lmDiag[i])
AORB_386:438:void_determineLMDirection(double,double,double,double):-sin * rik + cos * lmDiag[i] => -sin * rik / (cos * lmDiag[i])
AORB_387:438:void_determineLMDirection(double,double,double,double):-sin * rik + cos * lmDiag[i] => -sin * rik % (cos * lmDiag[i])
AORB_388:438:void_determineLMDirection(double,double,double,double):-sin * rik + cos * lmDiag[i] => -sin * rik - cos * lmDiag[i]
AORB_389:456:void_determineLMDirection(double,double,double,double):nSing - 1 => nSing * 1
AORB_390:456:void_determineLMDirection(double,double,double,double):nSing - 1 => nSing / 1
AORB_391:456:void_determineLMDirection(double,double,double,double):nSing - 1 => nSing % 1
AORB_392:456:void_determineLMDirection(double,double,double,double):nSing - 1 => nSing + 1
AORB_393:459:void_determineLMDirection(double,double,double,double):j + 1 => j * 1
AORB_394:459:void_determineLMDirection(double,double,double,double):j + 1 => j / 1
AORB_395:459:void_determineLMDirection(double,double,double,double):j + 1 => j % 1
AORB_396:459:void_determineLMDirection(double,double,double,double):j + 1 => j - 1
AORB_397:460:void_determineLMDirection(double,double,double,double):weightedJacobian[i][pj] * work[i] => weightedJacobian[i][pj] / work[i]
AORB_398:460:void_determineLMDirection(double,double,double,double):weightedJacobian[i][pj] * work[i] => weightedJacobian[i][pj] % work[i]
AORB_399:460:void_determineLMDirection(double,double,double,double):weightedJacobian[i][pj] * work[i] => weightedJacobian[i][pj] + work[i]
AORB_400:460:void_determineLMDirection(double,double,double,double):weightedJacobian[i][pj] * work[i] => weightedJacobian[i][pj] - work[i]
AORB_401:462:void_determineLMDirection(double,double,double,double):work[j] - sum => work[j] * sum
AORB_402:462:void_determineLMDirection(double,double,double,double):work[j] - sum => work[j] / sum
AORB_403:462:void_determineLMDirection(double,double,double,double):work[j] - sum => work[j] % sum
AORB_404:462:void_determineLMDirection(double,double,double,double):work[j] - sum => work[j] + sum
AORB_405:462:void_determineLMDirection(double,double,double,double):(work[j] - sum) / lmDiag[j] => (work[j] - sum) * lmDiag[j]
AORB_406:462:void_determineLMDirection(double,double,double,double):(work[j] - sum) / lmDiag[j] => (work[j] - sum) % lmDiag[j]
AORB_407:462:void_determineLMDirection(double,double,double,double):(work[j] - sum) / lmDiag[j] => work[j] - sum + lmDiag[j]
AORB_408:462:void_determineLMDirection(double,double,double,double):(work[j] - sum) / lmDiag[j] => work[j] - sum - lmDiag[j]
AORB_409:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * akk => akk / akk
AORB_410:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * akk => akk % akk
AORB_411:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * akk => akk + akk
AORB_412:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * akk => akk - akk
AORB_413:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):aki * aki => aki / aki
AORB_414:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):aki * aki => aki % aki
AORB_415:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):aki * aki => aki + aki
AORB_416:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):aki * aki => aki - aki
AORB_417:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * alpha => akk / alpha
AORB_418:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * alpha => akk % alpha
AORB_419:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * alpha => akk + alpha
AORB_420:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk * alpha => akk - alpha
AORB_421:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 - akk * alpha => ak2 * (akk * alpha)
AORB_422:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 - akk * alpha => ak2 / (akk * alpha)
AORB_423:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 - akk * alpha => ak2 % (akk * alpha)
AORB_424:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 - akk * alpha => ak2 + akk * alpha
AORB_425:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):1.0 / (ak2 - akk * alpha) => 1.0 * (ak2 - akk * alpha)
AORB_426:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):1.0 / (ak2 - akk * alpha) => 1.0 % (ak2 - akk * alpha)
AORB_427:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):1.0 / (ak2 - akk * alpha) => 1.0 + (ak2 - akk * alpha)
AORB_428:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):1.0 / (ak2 - akk * alpha) => 1.0 - (ak2 - akk * alpha)
AORB_429:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 => nC * 1
AORB_430:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 => nC / 1
AORB_431:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 => nC % 1
AORB_432:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 => nC + 1
AORB_433:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 - k => (nC - 1) * k
AORB_434:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 - k => (nC - 1) / k
AORB_435:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 - k => (nC - 1) % k
AORB_436:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC - 1 - k => nC - 1 + k
AORB_437:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k * dk
AORB_438:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k / dk
AORB_439:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k % dk
AORB_440:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k - dk
AORB_441:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]] => weightedJacobian[j][pk] / weightedJacobian[j][permutation[k + dk]]
AORB_442:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]] => weightedJacobian[j][pk] % weightedJacobian[j][permutation[k + dk]]
AORB_443:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]] => weightedJacobian[j][pk] + weightedJacobian[j][permutation[k + dk]]
AORB_444:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]] => weightedJacobian[j][pk] - weightedJacobian[j][permutation[k + dk]]
AORB_445:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k * dk
AORB_446:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k / dk
AORB_447:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k % dk
AORB_448:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k + dk => k - dk
AORB_449:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):gamma * weightedJacobian[j][pk] => gamma / weightedJacobian[j][pk]
AORB_450:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):gamma * weightedJacobian[j][pk] => gamma % weightedJacobian[j][pk]
AORB_451:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):gamma * weightedJacobian[j][pk] => gamma + weightedJacobian[j][pk]
AORB_452:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):gamma * weightedJacobian[j][pk] => gamma - weightedJacobian[j][pk]
AORB_453:537:void_qTy(double):weightedJacobian[i][pk] * y[i] => weightedJacobian[i][pk] / y[i]
AORB_454:537:void_qTy(double):weightedJacobian[i][pk] * y[i] => weightedJacobian[i][pk] % y[i]
AORB_455:537:void_qTy(double):weightedJacobian[i][pk] * y[i] => weightedJacobian[i][pk] + y[i]
AORB_456:537:void_qTy(double):weightedJacobian[i][pk] * y[i] => weightedJacobian[i][pk] - y[i]
AORB_457:541:void_qTy(double):gamma * weightedJacobian[i][pk] => gamma / weightedJacobian[i][pk]
AORB_458:541:void_qTy(double):gamma * weightedJacobian[i][pk] => gamma % weightedJacobian[i][pk]
AORB_459:541:void_qTy(double):gamma * weightedJacobian[i][pk] => gamma + weightedJacobian[i][pk]
AORB_460:541:void_qTy(double):gamma * weightedJacobian[i][pk] => gamma - weightedJacobian[i][pk]
AOIU_1:53:LevenbergMarquardtOptimizer():Precision.SAFE_MIN => -Precision.SAFE_MIN
AOIU_2:58:LevenbergMarquardtOptimizer(org.apache.commons.math3.optim.ConvergenceChecker):Precision.SAFE_MIN => -Precision.SAFE_MIN
AOIU_3:64:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double):initialStepBoundFactor => -initialStepBoundFactor
AOIU_4:65:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double):costRelativeTolerance => -costRelativeTolerance
AOIU_5:66:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double):parRelativeTolerance => -parRelativeTolerance
AOIU_6:67:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double):orthoTolerance => -orthoTolerance
AOIU_7:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double):threshold => -threshold
AOIU_8:73:LevenbergMarquardtOptimizer(double,double,double):costRelativeTolerance => -costRelativeTolerance
AOIU_9:73:LevenbergMarquardtOptimizer(double,double,double):parRelativeTolerance => -parRelativeTolerance
AOIU_10:73:LevenbergMarquardtOptimizer(double,double,double):orthoTolerance => -orthoTolerance
AOIU_11:73:LevenbergMarquardtOptimizer(double,double,double):Precision.SAFE_MIN => -Precision.SAFE_MIN
AOIU_12:79:LevenbergMarquardtOptimizer(double,double,double,double,double):initialStepBoundFactor => -initialStepBoundFactor
AOIU_13:80:LevenbergMarquardtOptimizer(double,double,double,double,double):costRelativeTolerance => -costRelativeTolerance
AOIU_14:81:LevenbergMarquardtOptimizer(double,double,double,double,double):parRelativeTolerance => -parRelativeTolerance
AOIU_15:82:LevenbergMarquardtOptimizer(double,double,double,double,double):orthoTolerance => -orthoTolerance
AOIU_16:83:LevenbergMarquardtOptimizer(double,double,double,double,double):threshold => -threshold
AOIU_17:89:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():getTarget().length => -getTarget().length
AOIU_18:91:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentPoint.length => -currentPoint.length
AOIU_19:92:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_20:92:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_21:93:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_22:94:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_23:95:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_24:96:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_25:97:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_26:100:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_27:101:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_28:102:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_29:103:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_30:104:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_31:105:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_32:106:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_33:107:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_34:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_35:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nR => -nR
AOIU_36:123:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_37:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_38:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_39:127:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_40:128:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pk => -pk
AOIU_41:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_42:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_43:133:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_44:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk => -dk
AOIU_45:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk => -dk
AOIU_46:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_47:138:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xk => -xk
AOIU_48:139:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dk => -dk
AOIU_49:141:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xNorm => -xNorm
AOIU_50:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xNorm => -xNorm
AOIU_51:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor => -initialStepBoundFactor
AOIU_52:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():initialStepBoundFactor => -initialStepBoundFactor
AOIU_53:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_54:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_55:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_56:147:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_57:148:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_58:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s => -s
AOIU_59:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_60:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_61:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_62:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_63:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_64:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():maxCosine => -maxCosine
AOIU_65:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():sum => -sum
AOIU_66:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s => -s
AOIU_67:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():maxCosine => -maxCosine
AOIU_68:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():orthoTolerance => -orthoTolerance
AOIU_69:159:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_70:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_71:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_72:163:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_73:163:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_74:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():ratio => -ratio
AOIU_75:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_76:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_77:167:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_78:168:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_79:170:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_80:177:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():delta => -delta
AOIU_81:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_82:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_83:180:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_84:182:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_85:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_86:183:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_87:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():s => -s
AOIU_88:186:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmNorm => -lmNorm
AOIU_89:188:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():delta => -delta
AOIU_90:188:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmNorm => -lmNorm
AOIU_91:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_92:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost => -previousCost
AOIU_93:196:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_94:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_95:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_96:200:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_97:201:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_98:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_99:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_100:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():i => -i
AOIU_101:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_102:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirJ => -dirJ
AOIU_103:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_104:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_105:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_106:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_107:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost => -previousCost
AOIU_108:212:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 => -coeff1
AOIU_109:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmPar => -lmPar
AOIU_110:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmNorm => -lmNorm
AOIU_111:213:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pc2 => -pc2
AOIU_112:214:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():coeff1 => -coeff1
AOIU_113:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():preRed => -preRed
AOIU_114:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed => -actRed
AOIU_115:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():ratio => -ratio
AOIU_116:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():actRed => -actRed
AOIU_117:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer => -dirDer
AOIU_118:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():dirDer => -dirDer
AOIU_119:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp => -tmp
AOIU_120:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():delta => -delta
AOIU_121:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmNorm => -lmNorm
AOIU_122:223:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():tmp => -tmp
AOIU_123:226:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():lmNorm => -lmNorm
AOIU_124:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():ratio => -ratio
AOIU_125:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_126:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():nC => -nC
AOIU_127:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_128:234:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():k => -k
AOIU_129:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xK => -xK
AOIU_130:237:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xNorm => -xNorm
AOIU_131:239:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():iter => -iter
AOIU_132:240:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_133:245:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():previousCost => -previousCost
AOIU_134:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_135:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():solvedCols => -solvedCols
AOIU_136:247:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():j => -j
AOIU_137:248:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():pj => -pj
AOIU_138:259:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():currentCost => -currentCost
AOIU_139:263:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():costRelativeTolerance => -costRelativeTolerance
AOIU_140:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():delta => -delta
AOIU_141:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():xNorm => -xNorm
AOIU_142:266:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():parRelativeTolerance => -parRelativeTolerance
AOIU_143:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():maxCosine => -maxCosine
AOIU_144:269:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize():orthoTolerance => -orthoTolerance
AOIU_145:279:void_determineLMParameter(double,double,double,double,double,double):weightedJacobian[0].length => -weightedJacobian[0].length
AOIU_146:280:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_147:280:void_determineLMParameter(double,double,double,double,double,double):rank => -rank
AOIU_148:281:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_149:283:void_determineLMParameter(double,double,double,double,double,double):rank => -rank
AOIU_150:283:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_151:283:void_determineLMParameter(double,double,double,double,double,double):nC => -nC
AOIU_152:286:void_determineLMParameter(double,double,double,double,double,double):rank => -rank
AOIU_153:286:void_determineLMParameter(double,double,double,double,double,double):k => -k
AOIU_154:287:void_determineLMParameter(double,double,double,double,double,double):k => -k
AOIU_155:288:void_determineLMParameter(double,double,double,double,double,double):pk => -pk
AOIU_156:288:void_determineLMParameter(double,double,double,double,double,double):pk => -pk
AOIU_157:289:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_158:289:void_determineLMParameter(double,double,double,double,double,double):k => -k
AOIU_159:290:void_determineLMParameter(double,double,double,double,double,double):ypk => -ypk
AOIU_160:290:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_161:290:void_determineLMParameter(double,double,double,double,double,double):pk => -pk
AOIU_162:292:void_determineLMParameter(double,double,double,double,double,double):ypk => -ypk
AOIU_163:295:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_164:295:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_165:296:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_166:297:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_167:297:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_168:298:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_169:299:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_170:301:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_171:302:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_172:303:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_173:303:void_determineLMParameter(double,double,double,double,double,double):delta => -delta
AOIU_174:309:void_determineLMParameter(double,double,double,double,double,double):rank => -rank
AOIU_175:309:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_176:310:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_177:310:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_178:311:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_179:312:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_180:312:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_181:315:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_182:315:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_183:316:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_184:318:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_185:318:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_186:319:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_187:319:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_188:319:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_189:321:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_190:321:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_191:322:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_192:323:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_193:325:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_194:325:void_determineLMParameter(double,double,double,double,double,double):delta => -delta
AOIU_195:328:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_196:328:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_197:329:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_198:331:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_199:331:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_200:332:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_201:332:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_202:332:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_203:334:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_204:335:void_determineLMParameter(double,double,double,double,double,double):sum => -sum
AOIU_205:337:void_determineLMParameter(double,double,double,double,double,double):sum2 => -sum2
AOIU_206:338:void_determineLMParameter(double,double,double,double,double,double):gNorm => -gNorm
AOIU_207:339:void_determineLMParameter(double,double,double,double,double,double):paru => -paru
AOIU_208:340:void_determineLMParameter(double,double,double,double,double,double):delta => -delta
AOIU_209:342:void_determineLMParameter(double,double,double,double,double,double):paru => -paru
AOIU_210:342:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_211:342:void_determineLMParameter(double,double,double,double,double,double):parl => -parl
AOIU_212:343:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_213:344:void_determineLMParameter(double,double,double,double,double,double):gNorm => -gNorm
AOIU_214:346:void_determineLMParameter(double,double,double,double,double,double):countdown => -countdown
AOIU_215:347:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_216:348:void_determineLMParameter(double,double,double,double,double,double):paru => -paru
AOIU_217:350:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_218:351:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_219:351:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_220:352:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_221:353:void_determineLMParameter(double,double,double,double,double,double):sPar => -sPar
AOIU_222:353:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_223:357:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_224:357:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_225:358:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_226:359:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_227:359:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_228:360:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_229:361:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_230:363:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_231:364:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_232:365:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_233:369:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_234:369:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_235:370:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_236:371:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_237:371:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_238:371:void_determineLMParameter(double,double,double,double,double,double):dxNorm => -dxNorm
AOIU_239:373:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_240:373:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_241:374:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_242:375:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_243:376:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_244:377:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_245:377:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_246:377:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_247:378:void_determineLMParameter(double,double,double,double,double,double):i => -i
AOIU_248:378:void_determineLMParameter(double,double,double,double,double,double):pj => -pj
AOIU_249:378:void_determineLMParameter(double,double,double,double,double,double):tmp => -tmp
AOIU_250:382:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_251:382:void_determineLMParameter(double,double,double,double,double,double):solvedCols => -solvedCols
AOIU_252:383:void_determineLMParameter(double,double,double,double,double,double):j => -j
AOIU_253:384:void_determineLMParameter(double,double,double,double,double,double):s => -s
AOIU_254:386:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_255:386:void_determineLMParameter(double,double,double,double,double,double):delta => -delta
AOIU_256:387:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_257:388:void_determineLMParameter(double,double,double,double,double,double):parl => -parl
AOIU_258:388:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_259:390:void_determineLMParameter(double,double,double,double,double,double):fp => -fp
AOIU_260:391:void_determineLMParameter(double,double,double,double,double,double):paru => -paru
AOIU_261:391:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_262:394:void_determineLMParameter(double,double,double,double,double,double):parl => -parl
AOIU_263:394:void_determineLMParameter(double,double,double,double,double,double):lmPar => -lmPar
AOIU_264:400:void_determineLMDirection(double,double,double,double):j => -j
AOIU_265:400:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_266:401:void_determineLMDirection(double,double,double,double):j => -j
AOIU_267:402:void_determineLMDirection(double,double,double,double):j => -j
AOIU_268:402:void_determineLMDirection(double,double,double,double):i => -i
AOIU_269:402:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_270:403:void_determineLMDirection(double,double,double,double):j => -j
AOIU_271:403:void_determineLMDirection(double,double,double,double):i => -i
AOIU_272:405:void_determineLMDirection(double,double,double,double):pj => -pj
AOIU_273:406:void_determineLMDirection(double,double,double,double):j => -j
AOIU_274:408:void_determineLMDirection(double,double,double,double):j => -j
AOIU_275:408:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_276:409:void_determineLMDirection(double,double,double,double):j => -j
AOIU_277:410:void_determineLMDirection(double,double,double,double):pj => -pj
AOIU_278:411:void_determineLMDirection(double,double,double,double):dpj => -dpj
AOIU_279:412:void_determineLMDirection(double,double,double,double):j => -j
AOIU_280:412:void_determineLMDirection(double,double,double,double):lmDiag.length => -lmDiag.length
AOIU_281:414:void_determineLMDirection(double,double,double,double):dpj => -dpj
AOIU_282:416:void_determineLMDirection(double,double,double,double):j => -j
AOIU_283:416:void_determineLMDirection(double,double,double,double):k => -k
AOIU_284:416:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_285:417:void_determineLMDirection(double,double,double,double):k => -k
AOIU_286:418:void_determineLMDirection(double,double,double,double):k => -k
AOIU_287:421:void_determineLMDirection(double,double,double,double):k => -k
AOIU_288:421:void_determineLMDirection(double,double,double,double):pk => -pk
AOIU_289:422:void_determineLMDirection(double,double,double,double):rkk => -rkk
AOIU_290:422:void_determineLMDirection(double,double,double,double):k => -k
AOIU_291:423:void_determineLMDirection(double,double,double,double):rkk => -rkk
AOIU_292:423:void_determineLMDirection(double,double,double,double):k => -k
AOIU_293:425:void_determineLMDirection(double,double,double,double):sin => -sin
AOIU_294:427:void_determineLMDirection(double,double,double,double):k => -k
AOIU_295:427:void_determineLMDirection(double,double,double,double):rkk => -rkk
AOIU_296:429:void_determineLMDirection(double,double,double,double):cos => -cos
AOIU_297:431:void_determineLMDirection(double,double,double,double):cos => -cos
AOIU_298:432:void_determineLMDirection(double,double,double,double):cos => -cos
AOIU_299:432:void_determineLMDirection(double,double,double,double):k => -k
AOIU_300:433:void_determineLMDirection(double,double,double,double):k => -k
AOIU_301:434:void_determineLMDirection(double,double,double,double):temp => -temp
AOIU_302:435:void_determineLMDirection(double,double,double,double):k => -k
AOIU_303:435:void_determineLMDirection(double,double,double,double):i => -i
AOIU_304:435:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_305:436:void_determineLMDirection(double,double,double,double):i => -i
AOIU_306:436:void_determineLMDirection(double,double,double,double):pk => -pk
AOIU_307:437:void_determineLMDirection(double,double,double,double):cos => -cos
AOIU_308:438:void_determineLMDirection(double,double,double,double):rik => -rik
AOIU_309:439:void_determineLMDirection(double,double,double,double):temp2 => -temp2
AOIU_310:443:void_determineLMDirection(double,double,double,double):j => -j
AOIU_311:443:void_determineLMDirection(double,double,double,double):j => -j
AOIU_312:444:void_determineLMDirection(double,double,double,double):j => -j
AOIU_313:446:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_314:447:void_determineLMDirection(double,double,double,double):j => -j
AOIU_315:447:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_316:449:void_determineLMDirection(double,double,double,double):j => -j
AOIU_317:451:void_determineLMDirection(double,double,double,double):nSing => -nSing
AOIU_318:451:void_determineLMDirection(double,double,double,double):solvedCols => -solvedCols
AOIU_319:455:void_determineLMDirection(double,double,double,double):nSing => -nSing
AOIU_320:456:void_determineLMDirection(double,double,double,double):nSing => -nSing
AOIU_321:456:void_determineLMDirection(double,double,double,double):j => -j
AOIU_322:457:void_determineLMDirection(double,double,double,double):j => -j
AOIU_323:459:void_determineLMDirection(double,double,double,double):j => -j
AOIU_324:459:void_determineLMDirection(double,double,double,double):i => -i
AOIU_325:459:void_determineLMDirection(double,double,double,double):nSing => -nSing
AOIU_326:460:void_determineLMDirection(double,double,double,double):i => -i
AOIU_327:460:void_determineLMDirection(double,double,double,double):pj => -pj
AOIU_328:460:void_determineLMDirection(double,double,double,double):i => -i
AOIU_329:462:void_determineLMDirection(double,double,double,double):j => -j
AOIU_330:462:void_determineLMDirection(double,double,double,double):j => -j
AOIU_331:465:void_determineLMDirection(double,double,double,double):j => -j
AOIU_332:465:void_determineLMDirection(double,double,double,double):lmDir.length => -lmDir.length
AOIU_333:466:void_determineLMDirection(double,double,double,double):j => -j
AOIU_334:474:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian.length => -weightedJacobian.length
AOIU_335:475:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):weightedJacobian[0].length => -weightedJacobian[0].length
AOIU_336:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_337:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC => -nC
AOIU_338:477:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_339:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):i => -i
AOIU_340:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nR => -nR
AOIU_341:480:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):i => -i
AOIU_342:480:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_343:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk => -akk
AOIU_344:483:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):norm2 => -norm2
AOIU_345:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_346:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC => -nC
AOIU_347:487:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):Double.NEGATIVE_INFINITY => -Double.NEGATIVE_INFINITY
AOIU_348:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_349:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):i => -i
AOIU_350:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC => -nC
AOIU_351:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_352:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_353:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nR => -nR
AOIU_354:491:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_355:491:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):i => -i
AOIU_356:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):aki => -aki
AOIU_357:495:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nR => -nR
AOIU_358:495:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC => -nC
AOIU_359:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):norm2 => -norm2
AOIU_360:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 => -ak2
AOIU_361:498:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):i => -i
AOIU_362:499:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):norm2 => -norm2
AOIU_363:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 => -ak2
AOIU_364:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):qrRankingThreshold => -qrRankingThreshold
AOIU_365:503:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_366:506:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nextColumn => -nextColumn
AOIU_367:507:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_368:508:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):pk => -pk
AOIU_369:509:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_370:509:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):pk => -pk
AOIU_371:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):akk => -akk
AOIU_372:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 => -ak2
AOIU_373:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):ak2 => -ak2
AOIU_374:512:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):betak => -betak
AOIU_375:513:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):alpha => -alpha
AOIU_376:514:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):alpha => -alpha
AOIU_377:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nC => -nC
AOIU_378:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):dk => -dk
AOIU_379:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_380:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_381:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nR => -nR
AOIU_382:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_383:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):pk => -pk
AOIU_384:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_385:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_386:520:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):betak => -betak
AOIU_387:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):k => -k
AOIU_388:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_389:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):nR => -nR
AOIU_390:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):gamma => -gamma
AOIU_391:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):j => -j
AOIU_392:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):pk => -pk
AOIU_393:526:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix):solvedCols => -solvedCols
AOIU_394:531:void_qTy(double):weightedJacobian.length => -weightedJacobian.length
AOIU_395:532:void_qTy(double):weightedJacobian[0].length => -weightedJacobian[0].length
AOIU_396:533:void_qTy(double):k => -k
AOIU_397:533:void_qTy(double):nC => -nC
AOIU_398:534:void_qTy(double):k => -k
AOIU_399:536:void_qTy(double):k => -k
AOIU_400:536:void_qTy(double):i => -i
AOIU_401:536:void_qTy(double):nR => -nR
AOIU_402:537:void_qTy(double):i => -i
AOIU_403:537:void_qTy(double):pk => -pk
AOIU_404:537:void_qTy(double):i => -i
AOIU_405:539:void_qTy(double):pk => -pk
AOIU_406:540:void_qTy(double):k => -k
AOIU_407:540:void_qTy(double):i => -i
AOIU_408:540:void_qTy(double):nR => -nR
AOIU_409:541:void_qTy(double):gamma => -gamma
AOIU_410:541:void_qTy(double):i => -i
AOIU_411:541:void_qTy(double):pk => -pk
ROR_1:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i > nR
ROR_2:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i >= nR
ROR_3:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i <= nR
ROR_4:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i == nR
ROR_5:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   i != nR
ROR_6:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   true
ROR_7:122:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i < nR  =>   false
ROR_8:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   k > solvedCols
ROR_9:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   k >= solvedCols
ROR_10:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   k <= solvedCols
ROR_11:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   k == solvedCols
ROR_12:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   k != solvedCols
ROR_13:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   true
ROR_14:126:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < solvedCols  =>   false
ROR_15:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k > nC
ROR_16:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k >= nC
ROR_17:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k <= nC
ROR_18:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k == nC
ROR_19:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k != nC
ROR_20:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   true
ROR_21:132:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   false
ROR_22:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   dk > 0
ROR_23:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   dk >= 0
ROR_24:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   dk < 0
ROR_25:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   dk <= 0
ROR_26:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   dk != 0
ROR_27:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   true
ROR_28:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk == 0  =>   false
ROR_29:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   xNorm > 0
ROR_30:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   xNorm >= 0
ROR_31:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   xNorm < 0
ROR_32:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   xNorm <= 0
ROR_33:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   xNorm != 0
ROR_34:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   true
ROR_35:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm == 0  =>   false
ROR_36:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   currentCost > 0
ROR_37:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   currentCost >= 0
ROR_38:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   currentCost < 0
ROR_39:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   currentCost <= 0
ROR_40:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   currentCost == 0
ROR_41:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   true
ROR_42:145:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost != 0  =>   false
ROR_43:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_44:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_45:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_46:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_47:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_48:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_49:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_50:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   s > 0
ROR_51:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   s >= 0
ROR_52:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   s < 0
ROR_53:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   s <= 0
ROR_54:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   s == 0
ROR_55:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   true
ROR_56:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): s != 0  =>   false
ROR_57:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i > j
ROR_58:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i >= j
ROR_59:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i < j
ROR_60:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i == j
ROR_61:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i != j
ROR_62:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   true
ROR_63:151:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   false
ROR_64:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   maxCosine > orthoTolerance
ROR_65:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   maxCosine >= orthoTolerance
ROR_66:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   maxCosine < orthoTolerance
ROR_67:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   maxCosine == orthoTolerance
ROR_68:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   maxCosine != orthoTolerance
ROR_69:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   true
ROR_70:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= orthoTolerance  =>   false
ROR_71:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j > nC
ROR_72:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j >= nC
ROR_73:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j <= nC
ROR_74:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j == nC
ROR_75:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   j != nC
ROR_76:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   true
ROR_77:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < nC  =>   false
ROR_78:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   ratio > 1.0e-4
ROR_79:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   ratio >= 1.0e-4
ROR_80:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   ratio <= 1.0e-4
ROR_81:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   ratio == 1.0e-4
ROR_82:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   ratio != 1.0e-4
ROR_83:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   true
ROR_84:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio < 1.0e-4  =>   false
ROR_85:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_86:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_87:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_88:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_89:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_90:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_91:166:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_92:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_93:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_94:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_95:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_96:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_97:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_98:179:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_99:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   0.1 * currentCost > previousCost
ROR_100:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   0.1 * currentCost >= previousCost
ROR_101:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   0.1 * currentCost <= previousCost
ROR_102:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   0.1 * currentCost == previousCost
ROR_103:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   0.1 * currentCost != previousCost
ROR_104:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   true
ROR_105:195:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost < previousCost  =>   false
ROR_106:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_107:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_108:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_109:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_110:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_111:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_112:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_113:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i > j
ROR_114:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i >= j
ROR_115:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i < j
ROR_116:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i == j
ROR_117:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   i != j
ROR_118:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   true
ROR_119:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): i <= j  =>   false
ROR_120:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_121:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_122:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_123:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_124:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_125:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_126:208:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_127:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   preRed > 0
ROR_128:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   preRed >= 0
ROR_129:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   preRed < 0
ROR_130:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   preRed <= 0
ROR_131:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   preRed != 0
ROR_132:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   true
ROR_133:216:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed == 0  =>   false
ROR_134:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   ratio > 0.25
ROR_135:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   ratio >= 0.25
ROR_136:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   ratio < 0.25
ROR_137:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   ratio == 0.25
ROR_138:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   ratio != 0.25
ROR_139:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   true
ROR_140:217:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 0.25  =>   false
ROR_141:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   actRed > 0
ROR_142:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   actRed >= 0
ROR_143:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   actRed <= 0
ROR_144:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   actRed == 0
ROR_145:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   actRed != 0
ROR_146:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   true
ROR_147:218:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): actRed < 0  =>   false
ROR_148:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   0.1 * currentCost > previousCost
ROR_149:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   0.1 * currentCost < previousCost
ROR_150:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   0.1 * currentCost <= previousCost
ROR_151:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   0.1 * currentCost == previousCost
ROR_152:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   0.1 * currentCost != previousCost
ROR_153:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   true
ROR_154:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost  =>   false
ROR_155:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   tmp > 0.1
ROR_156:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   tmp >= 0.1
ROR_157:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   tmp <= 0.1
ROR_158:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   tmp == 0.1
ROR_159:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   tmp != 0.1
ROR_160:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   true
ROR_161:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp < 0.1  =>   false
ROR_162:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   lmPar > 0
ROR_163:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   lmPar >= 0
ROR_164:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   lmPar < 0
ROR_165:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   lmPar <= 0
ROR_166:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   lmPar != 0
ROR_167:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   true
ROR_168:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0  =>   false
ROR_169:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   ratio > 0.75
ROR_170:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   ratio < 0.75
ROR_171:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   ratio <= 0.75
ROR_172:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   ratio == 0.75
ROR_173:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   ratio != 0.75
ROR_174:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   true
ROR_175:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 0.75  =>   false
ROR_176:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   ratio > 1.0e-4
ROR_177:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   ratio < 1.0e-4
ROR_178:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   ratio <= 1.0e-4
ROR_179:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   ratio == 1.0e-4
ROR_180:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   ratio != 1.0e-4
ROR_181:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   true
ROR_182:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio >= 1.0e-4  =>   false
ROR_183:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k > nC
ROR_184:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k >= nC
ROR_185:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k <= nC
ROR_186:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k == nC
ROR_187:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   k != nC
ROR_188:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   true
ROR_189:233:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): k < nC  =>   false
ROR_190:238:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checker != null  =>   checker == null
ROR_191:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j > solvedCols
ROR_192:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j >= solvedCols
ROR_193:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j <= solvedCols
ROR_194:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j == solvedCols
ROR_195:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   j != solvedCols
ROR_196:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   true
ROR_197:246:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): j < solvedCols  =>   false
ROR_198:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   FastMath.abs( actRed ) > costRelativeTolerance
ROR_199:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   FastMath.abs( actRed ) >= costRelativeTolerance
ROR_200:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   FastMath.abs( actRed ) < costRelativeTolerance
ROR_201:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   FastMath.abs( actRed ) == costRelativeTolerance
ROR_202:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   FastMath.abs( actRed ) != costRelativeTolerance
ROR_203:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   true
ROR_204:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance  =>   false
ROR_205:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   preRed > costRelativeTolerance
ROR_206:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   preRed >= costRelativeTolerance
ROR_207:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   preRed < costRelativeTolerance
ROR_208:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   preRed == costRelativeTolerance
ROR_209:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   preRed != costRelativeTolerance
ROR_210:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   true
ROR_211:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= costRelativeTolerance  =>   false
ROR_212:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio > 2.0
ROR_213:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio >= 2.0
ROR_214:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio < 2.0
ROR_215:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio == 2.0
ROR_216:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio != 2.0
ROR_217:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   true
ROR_218:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   false
ROR_219:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   delta > parRelativeTolerance * xNorm
ROR_220:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   delta >= parRelativeTolerance * xNorm
ROR_221:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   delta < parRelativeTolerance * xNorm
ROR_222:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   delta == parRelativeTolerance * xNorm
ROR_223:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   delta != parRelativeTolerance * xNorm
ROR_224:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   true
ROR_225:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= parRelativeTolerance * xNorm  =>   false
ROR_226:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   FastMath.abs( actRed ) > 2.2204e-16
ROR_227:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   FastMath.abs( actRed ) >= 2.2204e-16
ROR_228:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   FastMath.abs( actRed ) < 2.2204e-16
ROR_229:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   FastMath.abs( actRed ) == 2.2204e-16
ROR_230:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   FastMath.abs( actRed ) != 2.2204e-16
ROR_231:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   true
ROR_232:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16  =>   false
ROR_233:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   preRed > 2.2204e-16
ROR_234:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   preRed >= 2.2204e-16
ROR_235:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   preRed < 2.2204e-16
ROR_236:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   preRed == 2.2204e-16
ROR_237:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   preRed != 2.2204e-16
ROR_238:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   true
ROR_239:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): preRed <= 2.2204e-16  =>   false
ROR_240:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio > 2.0
ROR_241:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio >= 2.0
ROR_242:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio < 2.0
ROR_243:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio == 2.0
ROR_244:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   ratio != 2.0
ROR_245:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   true
ROR_246:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ratio <= 2.0  =>   false
ROR_247:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   delta > 2.2204e-16 * xNorm
ROR_248:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   delta >= 2.2204e-16 * xNorm
ROR_249:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   delta < 2.2204e-16 * xNorm
ROR_250:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   delta == 2.2204e-16 * xNorm
ROR_251:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   delta != 2.2204e-16 * xNorm
ROR_252:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   true
ROR_253:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta <= 2.2204e-16 * xNorm  =>   false
ROR_254:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   maxCosine > 2.2204e-16
ROR_255:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   maxCosine >= 2.2204e-16
ROR_256:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   maxCosine < 2.2204e-16
ROR_257:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   maxCosine == 2.2204e-16
ROR_258:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   maxCosine != 2.2204e-16
ROR_259:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   true
ROR_260:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): maxCosine <= 2.2204e-16  =>   false
ROR_261:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   j > rank
ROR_262:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   j >= rank
ROR_263:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   j <= rank
ROR_264:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   j == rank
ROR_265:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   j != rank
ROR_266:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   true
ROR_267:280:void_determineLMParameter(double,double,double,double,double,double): j < rank  =>   false
ROR_268:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   j > nC
ROR_269:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   j >= nC
ROR_270:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   j <= nC
ROR_271:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   j == nC
ROR_272:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   j != nC
ROR_273:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   true
ROR_274:283:void_determineLMParameter(double,double,double,double,double,double): j < nC  =>   false
ROR_275:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   k > 0
ROR_276:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   k < 0
ROR_277:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   k <= 0
ROR_278:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   k == 0
ROR_279:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   k != 0
ROR_280:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   true
ROR_281:286:void_determineLMParameter(double,double,double,double,double,double): k >= 0  =>   false
ROR_282:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   i > k
ROR_283:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   i >= k
ROR_284:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   i <= k
ROR_285:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   i == k
ROR_286:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   i != k
ROR_287:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   true
ROR_288:289:void_determineLMParameter(double,double,double,double,double,double): i < k  =>   false
ROR_289:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_290:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_291:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_292:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_293:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_294:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_295:295:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_296:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   fp > 0.1 * delta
ROR_297:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   fp >= 0.1 * delta
ROR_298:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   fp < 0.1 * delta
ROR_299:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   fp == 0.1 * delta
ROR_300:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   fp != 0.1 * delta
ROR_301:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   true
ROR_302:303:void_determineLMParameter(double,double,double,double,double,double): fp <= 0.1 * delta  =>   false
ROR_303:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   rank > solvedCols
ROR_304:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   rank >= solvedCols
ROR_305:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   rank < solvedCols
ROR_306:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   rank <= solvedCols
ROR_307:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   rank != solvedCols
ROR_308:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   true
ROR_309:309:void_determineLMParameter(double,double,double,double,double,double): rank == solvedCols  =>   false
ROR_310:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_311:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_312:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_313:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_314:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_315:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_316:310:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_317:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_318:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_319:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_320:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_321:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_322:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_323:315:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_324:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   i > j
ROR_325:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   i >= j
ROR_326:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   i <= j
ROR_327:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   i == j
ROR_328:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   i != j
ROR_329:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   true
ROR_330:318:void_determineLMParameter(double,double,double,double,double,double): i < j  =>   false
ROR_331:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_332:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_333:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_334:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_335:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_336:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_337:328:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_338:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   i > j
ROR_339:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   i >= j
ROR_340:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   i < j
ROR_341:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   i == j
ROR_342:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   i != j
ROR_343:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   true
ROR_344:331:void_determineLMParameter(double,double,double,double,double,double): i <= j  =>   false
ROR_345:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   paru > 0
ROR_346:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   paru >= 0
ROR_347:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   paru < 0
ROR_348:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   paru <= 0
ROR_349:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   paru != 0
ROR_350:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   true
ROR_351:339:void_determineLMParameter(double,double,double,double,double,double): paru == 0  =>   false
ROR_352:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar > 0
ROR_353:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar >= 0
ROR_354:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar < 0
ROR_355:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar <= 0
ROR_356:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar != 0
ROR_357:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   true
ROR_358:343:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   false
ROR_359:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   countdown > 0
ROR_360:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   countdown < 0
ROR_361:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   countdown <= 0
ROR_362:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   countdown == 0
ROR_363:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   countdown != 0
ROR_364:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   true
ROR_365:346:void_determineLMParameter(double,double,double,double,double,double): countdown >= 0  =>   false
ROR_366:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar > 0
ROR_367:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar >= 0
ROR_368:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar < 0
ROR_369:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar <= 0
ROR_370:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   lmPar != 0
ROR_371:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   true
ROR_372:347:void_determineLMParameter(double,double,double,double,double,double): lmPar == 0  =>   false
ROR_373:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_374:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_375:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_376:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_377:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_378:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_379:351:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_380:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_381:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_382:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_383:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_384:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_385:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_386:357:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_387:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   FastMath.abs( fp ) > 0.1 * delta
ROR_388:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   FastMath.abs( fp ) >= 0.1 * delta
ROR_389:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   FastMath.abs( fp ) < 0.1 * delta
ROR_390:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   FastMath.abs( fp ) == 0.1 * delta
ROR_391:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   FastMath.abs( fp ) != 0.1 * delta
ROR_392:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   true
ROR_393:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta  =>   false
ROR_394:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   parl > 0
ROR_395:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   parl >= 0
ROR_396:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   parl < 0
ROR_397:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   parl <= 0
ROR_398:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   parl != 0
ROR_399:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   true
ROR_400:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0  =>   false
ROR_401:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   fp > previousFP
ROR_402:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   fp >= previousFP
ROR_403:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   fp < previousFP
ROR_404:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   fp == previousFP
ROR_405:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   fp != previousFP
ROR_406:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   true
ROR_407:366:void_determineLMParameter(double,double,double,double,double,double): fp <= previousFP  =>   false
ROR_408:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   previousFP > 0
ROR_409:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   previousFP >= 0
ROR_410:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   previousFP <= 0
ROR_411:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   previousFP == 0
ROR_412:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   previousFP != 0
ROR_413:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   true
ROR_414:366:void_determineLMParameter(double,double,double,double,double,double): previousFP < 0  =>   false
ROR_415:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_416:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_417:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_418:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_419:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_420:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_421:369:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_422:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_423:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_424:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_425:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_426:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_427:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_428:373:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_429:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   i > solvedCols
ROR_430:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   i >= solvedCols
ROR_431:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   i <= solvedCols
ROR_432:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   i == solvedCols
ROR_433:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   i != solvedCols
ROR_434:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   true
ROR_435:377:void_determineLMParameter(double,double,double,double,double,double): i < solvedCols  =>   false
ROR_436:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_437:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_438:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_439:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_440:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_441:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   true
ROR_442:382:void_determineLMParameter(double,double,double,double,double,double): j < solvedCols  =>   false
ROR_443:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   fp >= 0
ROR_444:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   fp < 0
ROR_445:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   fp <= 0
ROR_446:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   fp == 0
ROR_447:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   fp != 0
ROR_448:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   true
ROR_449:387:void_determineLMParameter(double,double,double,double,double,double): fp > 0  =>   false
ROR_450:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   fp > 0
ROR_451:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   fp >= 0
ROR_452:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   fp <= 0
ROR_453:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   fp == 0
ROR_454:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   fp != 0
ROR_455:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   true
ROR_456:390:void_determineLMParameter(double,double,double,double,double,double): fp < 0  =>   false
ROR_457:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_458:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_459:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_460:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_461:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_462:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   true
ROR_463:400:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   false
ROR_464:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i > solvedCols
ROR_465:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i >= solvedCols
ROR_466:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i <= solvedCols
ROR_467:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i == solvedCols
ROR_468:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i != solvedCols
ROR_469:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   true
ROR_470:402:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   false
ROR_471:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_472:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_473:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_474:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_475:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_476:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   true
ROR_477:408:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   false
ROR_478:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   dpj > 0
ROR_479:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   dpj >= 0
ROR_480:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   dpj < 0
ROR_481:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   dpj <= 0
ROR_482:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   dpj == 0
ROR_483:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   true
ROR_484:411:void_determineLMDirection(double,double,double,double): dpj != 0  =>   false
ROR_485:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   k > solvedCols
ROR_486:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   k >= solvedCols
ROR_487:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   k <= solvedCols
ROR_488:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   k == solvedCols
ROR_489:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   k != solvedCols
ROR_490:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   true
ROR_491:416:void_determineLMDirection(double,double,double,double): k < solvedCols  =>   false
ROR_492:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   lmDiag[k] > 0
ROR_493:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   lmDiag[k] >= 0
ROR_494:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   lmDiag[k] < 0
ROR_495:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   lmDiag[k] <= 0
ROR_496:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   lmDiag[k] == 0
ROR_497:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   true
ROR_498:418:void_determineLMDirection(double,double,double,double): lmDiag[k] != 0  =>   false
ROR_499:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   FastMath.abs( rkk ) > FastMath.abs( lmDiag[k] )
ROR_500:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   FastMath.abs( rkk ) >= FastMath.abs( lmDiag[k] )
ROR_501:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   FastMath.abs( rkk ) <= FastMath.abs( lmDiag[k] )
ROR_502:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   FastMath.abs( rkk ) == FastMath.abs( lmDiag[k] )
ROR_503:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   FastMath.abs( rkk ) != FastMath.abs( lmDiag[k] )
ROR_504:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   true
ROR_505:422:void_determineLMDirection(double,double,double,double): FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )  =>   false
ROR_506:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i > solvedCols
ROR_507:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i >= solvedCols
ROR_508:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i <= solvedCols
ROR_509:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i == solvedCols
ROR_510:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   i != solvedCols
ROR_511:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   true
ROR_512:435:void_determineLMDirection(double,double,double,double): i < solvedCols  =>   false
ROR_513:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j > solvedCols
ROR_514:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j >= solvedCols
ROR_515:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j <= solvedCols
ROR_516:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j == solvedCols
ROR_517:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   j != solvedCols
ROR_518:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   true
ROR_519:447:void_determineLMDirection(double,double,double,double): j < solvedCols  =>   false
ROR_520:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   lmDiag[j] > 0
ROR_521:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   lmDiag[j] >= 0
ROR_522:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   lmDiag[j] < 0
ROR_523:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   lmDiag[j] <= 0
ROR_524:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   lmDiag[j] != 0
ROR_525:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   true
ROR_526:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0  =>   false
ROR_527:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   nSing > solvedCols
ROR_528:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   nSing >= solvedCols
ROR_529:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   nSing < solvedCols
ROR_530:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   nSing <= solvedCols
ROR_531:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   nSing != solvedCols
ROR_532:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   true
ROR_533:448:void_determineLMDirection(double,double,double,double): nSing == solvedCols  =>   false
ROR_534:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   nSing > solvedCols
ROR_535:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   nSing >= solvedCols
ROR_536:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   nSing <= solvedCols
ROR_537:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   nSing == solvedCols
ROR_538:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   nSing != solvedCols
ROR_539:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   true
ROR_540:451:void_determineLMDirection(double,double,double,double): nSing < solvedCols  =>   false
ROR_541:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   nSing >= 0
ROR_542:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   nSing < 0
ROR_543:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   nSing <= 0
ROR_544:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   nSing == 0
ROR_545:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   nSing != 0
ROR_546:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   true
ROR_547:455:void_determineLMDirection(double,double,double,double): nSing > 0  =>   false
ROR_548:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   j > 0
ROR_549:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   j < 0
ROR_550:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   j <= 0
ROR_551:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   j == 0
ROR_552:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   j != 0
ROR_553:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   true
ROR_554:456:void_determineLMDirection(double,double,double,double): j >= 0  =>   false
ROR_555:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   i > nSing
ROR_556:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   i >= nSing
ROR_557:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   i <= nSing
ROR_558:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   i == nSing
ROR_559:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   i != nSing
ROR_560:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   true
ROR_561:459:void_determineLMDirection(double,double,double,double): i < nSing  =>   false
ROR_562:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   j > lmDir.length
ROR_563:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   j >= lmDir.length
ROR_564:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   j <= lmDir.length
ROR_565:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   j == lmDir.length
ROR_566:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   j != lmDir.length
ROR_567:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   true
ROR_568:465:void_determineLMDirection(double,double,double,double): j < lmDir.length  =>   false
ROR_569:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k > nC
ROR_570:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k >= nC
ROR_571:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k <= nC
ROR_572:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k == nC
ROR_573:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k != nC
ROR_574:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   true
ROR_575:476:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   false
ROR_576:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   i > nR
ROR_577:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   i >= nR
ROR_578:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   i <= nR
ROR_579:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   i == nR
ROR_580:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   i != nR
ROR_581:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   true
ROR_582:479:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nR  =>   false
ROR_583:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k > nC
ROR_584:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k >= nC
ROR_585:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k <= nC
ROR_586:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k == nC
ROR_587:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   k != nC
ROR_588:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   true
ROR_589:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): k < nC  =>   false
ROR_590:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   i > nC
ROR_591:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   i >= nC
ROR_592:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   i <= nC
ROR_593:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   i == nC
ROR_594:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   i != nC
ROR_595:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   true
ROR_596:488:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): i < nC  =>   false
ROR_597:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j > nR
ROR_598:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j >= nR
ROR_599:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j <= nR
ROR_600:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j == nR
ROR_601:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j != nR
ROR_602:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   true
ROR_603:490:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   false
ROR_604:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   norm2 >= ak2
ROR_605:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   norm2 < ak2
ROR_606:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   norm2 <= ak2
ROR_607:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   norm2 == ak2
ROR_608:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   norm2 != ak2
ROR_609:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   true
ROR_610:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): norm2 > ak2  =>   false
ROR_611:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   ak2 > qrRankingThreshold
ROR_612:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   ak2 >= qrRankingThreshold
ROR_613:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   ak2 < qrRankingThreshold
ROR_614:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   ak2 == qrRankingThreshold
ROR_615:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   ak2 != qrRankingThreshold
ROR_616:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   true
ROR_617:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): ak2 <= qrRankingThreshold  =>   false
ROR_618:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   akk >= 0
ROR_619:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   akk < 0
ROR_620:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   akk <= 0
ROR_621:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   akk == 0
ROR_622:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   akk != 0
ROR_623:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   true
ROR_624:510:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): akk > 0  =>   false
ROR_625:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   dk >= 0
ROR_626:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   dk < 0
ROR_627:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   dk <= 0
ROR_628:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   dk == 0
ROR_629:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   dk != 0
ROR_630:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   true
ROR_631:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): dk > 0  =>   false
ROR_632:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j > nR
ROR_633:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j >= nR
ROR_634:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j <= nR
ROR_635:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j == nR
ROR_636:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j != nR
ROR_637:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   true
ROR_638:517:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   false
ROR_639:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j > nR
ROR_640:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j >= nR
ROR_641:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j <= nR
ROR_642:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j == nR
ROR_643:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   j != nR
ROR_644:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   true
ROR_645:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): j < nR  =>   false
ROR_646:533:void_qTy(double): k < nC  =>   k > nC
ROR_647:533:void_qTy(double): k < nC  =>   k >= nC
ROR_648:533:void_qTy(double): k < nC  =>   k <= nC
ROR_649:533:void_qTy(double): k < nC  =>   k == nC
ROR_650:533:void_qTy(double): k < nC  =>   k != nC
ROR_651:533:void_qTy(double): k < nC  =>   true
ROR_652:533:void_qTy(double): k < nC  =>   false
ROR_653:536:void_qTy(double): i < nR  =>   i > nR
ROR_654:536:void_qTy(double): i < nR  =>   i >= nR
ROR_655:536:void_qTy(double): i < nR  =>   i <= nR
ROR_656:536:void_qTy(double): i < nR  =>   i == nR
ROR_657:536:void_qTy(double): i < nR  =>   i != nR
ROR_658:536:void_qTy(double): i < nR  =>   true
ROR_659:536:void_qTy(double): i < nR  =>   false
ROR_660:540:void_qTy(double): i < nR  =>   i > nR
ROR_661:540:void_qTy(double): i < nR  =>   i >= nR
ROR_662:540:void_qTy(double): i < nR  =>   i <= nR
ROR_663:540:void_qTy(double): i < nR  =>   i == nR
ROR_664:540:void_qTy(double): i < nR  =>   i != nR
ROR_665:540:void_qTy(double): i < nR  =>   true
ROR_666:540:void_qTy(double): i < nR  =>   false
ROR_667:548:void_checkParameters(): getLowerBound() != null  =>   getLowerBound() == null
ROR_668:548:void_checkParameters(): getUpperBound() != null  =>   getUpperBound() == null
COR_1:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost || tmp < 0.1  =>   0.1 * currentCost >= previousCost && tmp < 0.1
COR_2:219:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): 0.1 * currentCost >= previousCost || tmp < 0.1  =>   0.1 * currentCost >= previousCost ^ tmp < 0.1
COR_3:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0 || ratio >= 0.75  =>   lmPar == 0 && ratio >= 0.75
COR_4:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): lmPar == 0 || ratio >= 0.75  =>   lmPar == 0 ^ ratio >= 0.75
COR_5:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance  =>   FastMath.abs( actRed ) <= costRelativeTolerance || preRed <= costRelativeTolerance
COR_6:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance  =>   FastMath.abs( actRed ) <= costRelativeTolerance ^ preRed <= costRelativeTolerance
COR_7:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0  =>   FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance || ratio <= 2.0
COR_8:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0  =>   (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance) ^ ratio <= 2.0
COR_9:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm  =>   FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 && delta <= parRelativeTolerance * xNorm
COR_10:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm  =>   (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) ^ delta <= parRelativeTolerance * xNorm
COR_11:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16  =>   FastMath.abs( actRed ) <= 2.2204e-16 || preRed <= 2.2204e-16
COR_12:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16  =>   FastMath.abs( actRed ) <= 2.2204e-16 ^ preRed <= 2.2204e-16
COR_13:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0  =>   FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 || ratio <= 2.0
COR_14:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0  =>   (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16) ^ ratio <= 2.0
COR_15:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0 && fp <= previousFP  =>   parl == 0 || fp <= previousFP
COR_16:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0 && fp <= previousFP  =>   parl == 0 ^ fp <= previousFP
COR_17:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0 && fp <= previousFP && previousFP < 0  =>   parl == 0 && fp <= previousFP || previousFP < 0
COR_18:366:void_determineLMParameter(double,double,double,double,double,double): parl == 0 && fp <= previousFP && previousFP < 0  =>   (parl == 0 && fp <= previousFP) ^ previousFP < 0
COR_19:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0  =>   FastMath.abs( fp ) <= 0.1 * delta && (parl == 0 && fp <= previousFP && previousFP < 0)
COR_20:366:void_determineLMParameter(double,double,double,double,double,double): FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0  =>   FastMath.abs( fp ) <= 0.1 * delta ^ (parl == 0 && fp <= previousFP && previousFP < 0)
COR_21:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0 && nSing == solvedCols  =>   lmDiag[j] == 0 || nSing == solvedCols
COR_22:448:void_determineLMDirection(double,double,double,double): lmDiag[j] == 0 && nSing == solvedCols  =>   lmDiag[j] == 0 ^ nSing == solvedCols
COR_23:494:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): Double.isInfinite( norm2 ) || Double.isNaN( norm2 )  =>   Double.isInfinite( norm2 ) && Double.isNaN( norm2 )
COR_24:494:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): Double.isInfinite( norm2 ) || Double.isNaN( norm2 )  =>   Double.isInfinite( norm2 ) ^ Double.isNaN( norm2 )
COR_25:548:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null && getUpperBound() != null
COR_26:548:void_checkParameters(): getLowerBound() != null || getUpperBound() != null  =>   getLowerBound() != null ^ getUpperBound() != null
SDL_1:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_2:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_3:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_4:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.qrRankingThreshold = threshold;
SDL_5:68:LevenbergMarquardtOptimizer(double,org.apache.commons.math3.optim.ConvergenceChecker,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance;
SDL_6:83:LevenbergMarquardtOptimizer(double,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_7:83:LevenbergMarquardtOptimizer(double,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_8:83:LevenbergMarquardtOptimizer(double,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;
SDL_9:83:LevenbergMarquardtOptimizer(double,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.qrRankingThreshold = threshold;
SDL_10:83:LevenbergMarquardtOptimizer(double,double,double,double,double): this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold;  =>   this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance;
SDL_11:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_12:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_13:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_14:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_15:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_16:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_17:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_18:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }
SDL_19:117:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) {     ++iter;     final org.apache.commons.math3.optim.PointVectorValuePair previous = current;     qrDecomposition( computeWeightedJacobian( currentPoint ) );     weightedResidual = weightMatrixSqrt.operate( currentResiduals );     for (int i = 0; i < nR; i++) {         qtf[i] = weightedResidual[i];     }     qTy( qtf );     for (int k = 0; k < solvedCols; ++k) {         int pk = permutation[k];         weightedJacobian[k][pk] = diagR[pk];     }     if (firstIteration) {         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double dk = jacNorm[k];             if (dk == 0) {                 dk = 1.0;             }             double xk = dk * currentPoint[k];             xNorm += xk * xk;             diag[k] = dk;         }         xNorm = FastMath.sqrt( xNorm );         delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;     }     double maxCosine = 0;     if (currentCost != 0) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double s = jacNorm[pj];             if (s != 0) {                 double sum = 0;                 for (int i = 0; i <= j; ++i) {                     sum += weightedJacobian[i][pj] * qtf[i];                 }                 maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );             }         }     }     if (maxCosine <= orthoTolerance) {         setCost( currentCost );         return current;     }     for (int j = 0; j < nC; ++j) {         diag[j] = FastMath.max( diag[j], jacNorm[j] );     }     for (double ratio = 0; ratio < 1.0e-4;) {         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             oldX[pj] = currentPoint[pj];         }         final double previousCost = currentCost;         double[] tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         determineLMParameter( qtf, delta, diag, work1, work2, work3 );         double lmNorm = 0;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             lmDir[pj] = -lmDir[pj];             currentPoint[pj] = oldX[pj] + lmDir[pj];             double s = diag[pj] * lmDir[pj];             lmNorm += s * s;         }         lmNorm = FastMath.sqrt( lmNorm );         if (firstIteration) {             delta = FastMath.min( delta, lmNorm );         }         currentObjective = computeObjectiveValue( currentPoint );         currentResiduals = computeResiduals( currentObjective );         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         currentCost = computeCost( currentResiduals );         double actRed = -1.0;         if (0.1 * currentCost < previousCost) {             double r = currentCost / previousCost;             actRed = 1.0 - r * r;         }         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             double dirJ = lmDir[pj];             work1[j] = 0;             for (int i = 0; i <= j; ++i) {                 work1[i] += weightedJacobian[i][pj] * dirJ;             }         }         double coeff1 = 0;         for (int j = 0; j < solvedCols; ++j) {             coeff1 += work1[j] * work1[j];         }         double pc2 = previousCost * previousCost;         coeff1 = coeff1 / pc2;         double coeff2 = lmPar * lmNorm * lmNorm / pc2;         double preRed = coeff1 + 2 * coeff2;         double dirDer = -(coeff1 + coeff2);         ratio = preRed == 0 ? 0 : actRed / preRed;         if (ratio <= 0.25) {             double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;             if (0.1 * currentCost >= previousCost || tmp < 0.1) {                 tmp = 0.1;             }             delta = tmp * FastMath.min( delta, 10.0 * lmNorm );             lmPar /= tmp;         } else {             if (lmPar == 0 || ratio >= 0.75) {                 delta = 2 * lmNorm;                 lmPar *= 0.5;             }         }         if (ratio >= 1.0e-4) {             firstIteration = false;             xNorm = 0;             for (int k = 0; k < nC; ++k) {                 double xK = diag[k] * currentPoint[k];                 xNorm += xK * xK;             }             xNorm = FastMath.sqrt( xNorm );             if (checker != null) {                 if (checker.converged( iter, previous, current )) {                     setCost( currentCost );                     return current;                 }             }         } else {             currentCost = previousCost;             for (int j = 0; j < solvedCols; ++j) {                 int pj = permutation[j];                 currentPoint[pj] = oldX[pj];             }             tmpVec = weightedResidual;             weightedResidual = oldRes;             oldRes = tmpVec;             tmpVec = currentObjective;             currentObjective = oldObj;             oldObj = tmpVec;             current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );         }         if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {             setCost( currentCost );             return current;         }         if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );         } else {             if (delta <= 2.2204e-16 * xNorm) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );             } else {                 if (maxCosine <= 2.2204e-16) {                     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );                 }             }         }     } }  =>   checkParameters(); final int nR = getTarget().length; final double[] currentPoint = getStartPoint(); final int nC = currentPoint.length; solvedCols = FastMath.min( nR, nC ); diagR = new double[nC]; jacNorm = new double[nC]; beta = new double[nC]; permutation = new int[nC]; lmDir = new double[nC]; double delta = 0; double xNorm = 0; double[] diag = new double[nC]; double[] oldX = new double[nC]; double[] oldRes = new double[nR]; double[] oldObj = new double[nR]; double[] qtf = new double[nR]; double[] work1 = new double[nC]; double[] work2 = new double[nC]; double[] work3 = new double[nC]; final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot(); double[] currentObjective = computeObjectiveValue( currentPoint ); double[] currentResiduals = computeResiduals( currentObjective ); org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double currentCost = computeCost( currentResiduals ); lmPar = 0; boolean firstIteration = true; int iter = 0; final org.apache.commons.math3.optim.ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
SDL_20:273:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_21:273:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_22:273:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_23:271:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_24:273:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_25:270:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_26:260:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_27:261:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_28:270:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_29:271:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_30:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); } for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   ++iter; final org.apache.commons.math3.optim.PointVectorValuePair previous = current; qrDecomposition( computeWeightedJacobian( currentPoint ) ); weightedResidual = weightMatrixSqrt.operate( currentResiduals ); for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; } qTy( qtf ); for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; } if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; } double maxCosine = 0; if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } } if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; } for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); }
SDL_31:123:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): qtf[i] = weightedResidual[i];  =>  
SDL_32:125:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; }  =>   for (int i = 0;; i++) {     qtf[i] = weightedResidual[i]; }
SDL_33:125:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i < nR; i++) {     qtf[i] = weightedResidual[i]; }  =>   for (int i = 0; i < nR;) {     qtf[i] = weightedResidual[i]; }
SDL_34:128:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pk = permutation[k]; weightedJacobian[k][pk] = diagR[pk];  =>   int pk = permutation[k];
SDL_35:130:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; }  =>   for (int k = 0;; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; }
SDL_36:130:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < solvedCols; ++k) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; }  =>   for (int k = 0; k < solvedCols;) {     int pk = permutation[k];     weightedJacobian[k][pk] = diagR[pk]; }
SDL_37:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;  =>   for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;
SDL_38:134:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;  =>   xNorm = 0; xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;
SDL_39:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;  =>   xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;
SDL_40:142:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm ); delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm;  =>   xNorm = 0; for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; } xNorm = FastMath.sqrt( xNorm );
SDL_41:144:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (firstIteration) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; }  =>   if (true) {     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double dk = jacNorm[k];         if (dk == 0) {             dk = 1.0;         }         double xk = dk * currentPoint[k];         xNorm += xk * xk;         diag[k] = dk;     }     xNorm = FastMath.sqrt( xNorm );     delta = xNorm == 0 ? initialStepBoundFactor : initialStepBoundFactor * xNorm; }
SDL_42:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double dk = jacNorm[k]; if (dk == 0) {     dk = 1.0; } double xk = dk * currentPoint[k]; xNorm += xk * xk; diag[k] = dk;  =>   double dk = jacNorm[k]; double xk = dk * currentPoint[k]; xNorm += xk * xk; diag[k] = dk;
SDL_43:139:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double dk = jacNorm[k]; if (dk == 0) {     dk = 1.0; } double xk = dk * currentPoint[k]; xNorm += xk * xk; diag[k] = dk;  =>   double dk = jacNorm[k]; if (dk == 0) {     dk = 1.0; } double xk = dk * currentPoint[k]; diag[k] = dk;
SDL_44:139:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double dk = jacNorm[k]; if (dk == 0) {     dk = 1.0; } double xk = dk * currentPoint[k]; xNorm += xk * xk; diag[k] = dk;  =>   double dk = jacNorm[k]; if (dk == 0) {     dk = 1.0; } double xk = dk * currentPoint[k]; xNorm += xk * xk;
SDL_45:141:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; }  =>   for (int k = 0;; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; }
SDL_46:141:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; }  =>   for (int k = 0; k < nC;) {     double dk = jacNorm[k];     if (dk == 0) {         dk = 1.0;     }     double xk = dk * currentPoint[k];     xNorm += xk * xk;     diag[k] = dk; }
SDL_47:135:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): dk = 1.0;  =>  
SDL_48:137:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (dk == 0) {     dk = 1.0; }  =>   if (true) {     dk = 1.0; }
SDL_49:146:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = jacNorm[pj];     if (s != 0) {         double sum = 0;         for (int i = 0; i <= j; ++i) {             sum += weightedJacobian[i][pj] * qtf[i];         }         maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );     } }  =>  
SDL_50:158:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (currentCost != 0) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } }  =>   if (true) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = jacNorm[pj];         if (s != 0) {             double sum = 0;             for (int i = 0; i <= j; ++i) {                 sum += weightedJacobian[i][pj] * qtf[i];             }             maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );         }     } }
SDL_51:149:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) {     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qtf[i];     }     maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) ); }  =>   int pj = permutation[j]; double s = jacNorm[pj];
SDL_52:157:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = jacNorm[pj];     if (s != 0) {         double sum = 0;         for (int i = 0; i <= j; ++i) {             sum += weightedJacobian[i][pj] * qtf[i];         }         maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );     } }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double s = jacNorm[pj];     if (s != 0) {         double sum = 0;         for (int i = 0; i <= j; ++i) {             sum += weightedJacobian[i][pj] * qtf[i];         }         maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );     } }
SDL_53:157:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = jacNorm[pj];     if (s != 0) {         double sum = 0;         for (int i = 0; i <= j; ++i) {             sum += weightedJacobian[i][pj] * qtf[i];         }         maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );     } }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double s = jacNorm[pj];     if (s != 0) {         double sum = 0;         for (int i = 0; i <= j; ++i) {             sum += weightedJacobian[i][pj] * qtf[i];         }         maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );     } }
SDL_54:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; } maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );  =>   double sum = 0; maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );
SDL_55:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; } maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) );  =>   double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; }
SDL_56:156:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (s != 0) {     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qtf[i];     }     maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) ); }  =>   if (true) {     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qtf[i];     }     maxCosine = FastMath.max( maxCosine, FastMath.abs( sum ) / (s * currentCost) ); }
SDL_57:152:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): sum += weightedJacobian[i][pj] * qtf[i];  =>  
SDL_58:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; }  =>   for (int i = 0;; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; }
SDL_59:154:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qtf[i]; }  =>   for (int i = 0; i <= j;) {     sum += weightedJacobian[i][pj] * qtf[i]; }
SDL_60:160:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): setCost( currentCost ); return current;  =>   return current;
SDL_61:162:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (maxCosine <= orthoTolerance) {     setCost( currentCost );     return current; }  =>   if (true) {     setCost( currentCost );     return current; }
SDL_62:163:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): diag[j] = FastMath.max( diag[j], jacNorm[j] );  =>  
SDL_63:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); }  =>   for (int j = 0;; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); }
SDL_64:165:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < nC; ++j) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); }  =>   for (int j = 0; j < nC;) {     diag[j] = FastMath.max( diag[j], jacNorm[j] ); }
SDL_65:269:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_66:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_67:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_68:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_69:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_70:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_71:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_72:266:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_73:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_74:270:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_75:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_76:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_77:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_78:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_79:269:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_80:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_81:270:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_82:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_83:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_84:260:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_85:245:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_86:269:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_87:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; } if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; } final double previousCost = currentCost; double[] tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; determineLMParameter( qtf, delta, diag, work1, work2, work3 ); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; } lmNorm = FastMath.sqrt( lmNorm ); if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); } currentObjective = computeObjectiveValue( currentPoint ); currentResiduals = computeResiduals( currentObjective ); current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); currentCost = computeCost( currentResiduals ); double actRed = -1.0; if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = preRed == 0 ? 0 : actRed / preRed; if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } } if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); } if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; }
SDL_88:274:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (double ratio = 0; ratio < 1.0e-4;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }  =>   for (double ratio = 0;;) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         oldX[pj] = currentPoint[pj];     }     final double previousCost = currentCost;     double[] tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     determineLMParameter( qtf, delta, diag, work1, work2, work3 );     double lmNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         lmDir[pj] = -lmDir[pj];         currentPoint[pj] = oldX[pj] + lmDir[pj];         double s = diag[pj] * lmDir[pj];         lmNorm += s * s;     }     lmNorm = FastMath.sqrt( lmNorm );     if (firstIteration) {         delta = FastMath.min( delta, lmNorm );     }     currentObjective = computeObjectiveValue( currentPoint );     currentResiduals = computeResiduals( currentObjective );     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     currentCost = computeCost( currentResiduals );     double actRed = -1.0;     if (0.1 * currentCost < previousCost) {         double r = currentCost / previousCost;         actRed = 1.0 - r * r;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double dirJ = lmDir[pj];         work1[j] = 0;         for (int i = 0; i <= j; ++i) {             work1[i] += weightedJacobian[i][pj] * dirJ;         }     }     double coeff1 = 0;     for (int j = 0; j < solvedCols; ++j) {         coeff1 += work1[j] * work1[j];     }     double pc2 = previousCost * previousCost;     coeff1 = coeff1 / pc2;     double coeff2 = lmPar * lmNorm * lmNorm / pc2;     double preRed = coeff1 + 2 * coeff2;     double dirDer = -(coeff1 + coeff2);     ratio = preRed == 0 ? 0 : actRed / preRed;     if (ratio <= 0.25) {         double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;         if (0.1 * currentCost >= previousCost || tmp < 0.1) {             tmp = 0.1;         }         delta = tmp * FastMath.min( delta, 10.0 * lmNorm );         lmPar /= tmp;     } else {         if (lmPar == 0 || ratio >= 0.75) {             delta = 2 * lmNorm;             lmPar *= 0.5;         }     }     if (ratio >= 1.0e-4) {         firstIteration = false;         xNorm = 0;         for (int k = 0; k < nC; ++k) {             double xK = diag[k] * currentPoint[k];             xNorm += xK * xK;         }         xNorm = FastMath.sqrt( xNorm );         if (checker != null) {             if (checker.converged( iter, previous, current )) {                 setCost( currentCost );                 return current;             }         }     } else {         currentCost = previousCost;         for (int j = 0; j < solvedCols; ++j) {             int pj = permutation[j];             currentPoint[pj] = oldX[pj];         }         tmpVec = weightedResidual;         weightedResidual = oldRes;         oldRes = tmpVec;         tmpVec = currentObjective;         currentObjective = oldObj;         oldObj = tmpVec;         current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );     }     if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {         setCost( currentCost );         return current;     }     if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );     } else {         if (delta <= 2.2204e-16 * xNorm) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );         } else {             if (maxCosine <= 2.2204e-16) {                 throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );             }         }     } }
SDL_89:168:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; oldX[pj] = currentPoint[pj];  =>   int pj = permutation[j];
SDL_90:170:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; }
SDL_91:170:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     oldX[pj] = currentPoint[pj]; }
SDL_92:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; currentPoint[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s;  =>   int pj = permutation[j]; currentPoint[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s;
SDL_93:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; currentPoint[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s;  =>   int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s;
SDL_94:184:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; currentPoint[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s;  =>   int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; currentPoint[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj];
SDL_95:186:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; }
SDL_96:186:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     lmDir[pj] = -lmDir[pj];     currentPoint[pj] = oldX[pj] + lmDir[pj];     double s = diag[pj] * lmDir[pj];     lmNorm += s * s; }
SDL_97:188:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta = FastMath.min( delta, lmNorm );  =>  
SDL_98:190:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (firstIteration) {     delta = FastMath.min( delta, lmNorm ); }  =>   if (true) {     delta = FastMath.min( delta, lmNorm ); }
SDL_99:197:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double r = currentCost / previousCost; actRed = 1.0 - r * r;  =>   double r = currentCost / previousCost;
SDL_100:199:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (0.1 * currentCost < previousCost) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; }  =>   if (true) {     double r = currentCost / previousCost;     actRed = 1.0 - r * r; }
SDL_101:205:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }  =>   int pj = permutation[j]; double dirJ = lmDir[pj]; for (int i = 0; i <= j; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }
SDL_102:203:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }  =>   int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0;
SDL_103:207:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } }
SDL_104:207:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double dirJ = lmDir[pj];     work1[j] = 0;     for (int i = 0; i <= j; ++i) {         work1[i] += weightedJacobian[i][pj] * dirJ;     } }
SDL_105:204:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): work1[i] += weightedJacobian[i][pj] * dirJ;  =>  
SDL_106:206:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i <= j; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }  =>   for (int i = 0;; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }
SDL_107:206:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int i = 0; i <= j; ++i) {     work1[i] += weightedJacobian[i][pj] * dirJ; }  =>   for (int i = 0; i <= j;) {     work1[i] += weightedJacobian[i][pj] * dirJ; }
SDL_108:209:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): coeff1 += work1[j] * work1[j];  =>  
SDL_109:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; }  =>   for (int j = 0;; ++j) {     coeff1 += work1[j] * work1[j]; }
SDL_110:211:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     coeff1 += work1[j] * work1[j]; }  =>   for (int j = 0; j < solvedCols;) {     coeff1 += work1[j] * work1[j]; }
SDL_111:221:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; } delta = tmp * FastMath.min( delta, 10.0 * lmNorm ); lmPar /= tmp;  =>   double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; delta = tmp * FastMath.min( delta, 10.0 * lmNorm ); lmPar /= tmp;
SDL_112:223:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; } delta = tmp * FastMath.min( delta, 10.0 * lmNorm ); lmPar /= tmp;  =>   double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; } lmPar /= tmp;
SDL_113:223:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; } delta = tmp * FastMath.min( delta, 10.0 * lmNorm ); lmPar /= tmp;  =>   double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5; if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; } delta = tmp * FastMath.min( delta, 10.0 * lmNorm );
SDL_114:230:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (ratio <= 0.25) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } }  =>   if (true) {     double tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;     if (0.1 * currentCost >= previousCost || tmp < 0.1) {         tmp = 0.1;     }     delta = tmp * FastMath.min( delta, 10.0 * lmNorm );     lmPar /= tmp; } else {     if (lmPar == 0 || ratio >= 0.75) {         delta = 2 * lmNorm;         lmPar *= 0.5;     } }
SDL_115:225:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (lmPar == 0 || ratio >= 0.75) {     delta = 2 * lmNorm;     lmPar *= 0.5; }  =>  
SDL_116:220:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): tmp = 0.1;  =>  
SDL_117:222:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (0.1 * currentCost >= previousCost || tmp < 0.1) {     tmp = 0.1; }  =>   if (true) {     tmp = 0.1; }
SDL_118:227:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta = 2 * lmNorm; lmPar *= 0.5;  =>   lmPar *= 0.5;
SDL_119:227:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): delta = 2 * lmNorm; lmPar *= 0.5;  =>   delta = 2 * lmNorm;
SDL_120:229:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (lmPar == 0 || ratio >= 0.75) {     delta = 2 * lmNorm;     lmPar *= 0.5; }  =>   if (true) {     delta = 2 * lmNorm;     lmPar *= 0.5; }
SDL_121:243:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }
SDL_122:243:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   firstIteration = false; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }
SDL_123:240:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   firstIteration = false; xNorm = 0; xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }
SDL_124:243:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }
SDL_125:238:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm ); if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   firstIteration = false; xNorm = 0; for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; } xNorm = FastMath.sqrt( xNorm );
SDL_126:258:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (ratio >= 1.0e-4) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); }  =>   if (true) {     firstIteration = false;     xNorm = 0;     for (int k = 0; k < nC; ++k) {         double xK = diag[k] * currentPoint[k];         xNorm += xK * xK;     }     xNorm = FastMath.sqrt( xNorm );     if (checker != null) {         if (checker.converged( iter, previous, current )) {             setCost( currentCost );             return current;         }     } } else {     currentCost = previousCost;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         currentPoint[pj] = oldX[pj];     }     tmpVec = weightedResidual;     weightedResidual = oldRes;     oldRes = tmpVec;     tmpVec = currentObjective;     currentObjective = oldObj;     oldObj = tmpVec;     current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective ); }
SDL_127:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_128:253:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_129:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_130:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_131:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_132:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_133:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_134:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );
SDL_135:256:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec; current = new org.apache.commons.math3.optim.PointVectorValuePair( currentPoint, currentObjective );  =>   currentCost = previousCost; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; } tmpVec = weightedResidual; weightedResidual = oldRes; oldRes = tmpVec; tmpVec = currentObjective; currentObjective = oldObj; oldObj = tmpVec;
SDL_136:235:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): double xK = diag[k] * currentPoint[k]; xNorm += xK * xK;  =>   double xK = diag[k] * currentPoint[k];
SDL_137:237:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; }  =>   for (int k = 0;; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; }
SDL_138:237:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int k = 0; k < nC; ++k) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; }  =>   for (int k = 0; k < nC;) {     double xK = diag[k] * currentPoint[k];     xNorm += xK * xK; }
SDL_139:239:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (checker.converged( iter, previous, current )) {     setCost( currentCost );     return current; }  =>  
SDL_140:244:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (checker != null) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }  =>   if (true) {     if (checker.converged( iter, previous, current )) {         setCost( currentCost );         return current;     } }
SDL_141:241:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): setCost( currentCost ); return current;  =>   return current;
SDL_142:243:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (checker.converged( iter, previous, current )) {     setCost( currentCost );     return current; }  =>   if (true) {     setCost( currentCost );     return current; }
SDL_143:248:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): int pj = permutation[j]; currentPoint[pj] = oldX[pj];  =>   int pj = permutation[j];
SDL_144:250:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; }
SDL_145:250:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     currentPoint[pj] = oldX[pj]; }
SDL_146:260:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): setCost( currentCost ); return current;  =>   return current;
SDL_147:262:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (FastMath.abs( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 || delta <= parRelativeTolerance * xNorm) {     setCost( currentCost );     return current; }  =>   if (true) {     setCost( currentCost );     return current; }
SDL_148:263:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance );  =>  
SDL_149:273:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (FastMath.abs( actRed ) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }  =>   if (true) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance ); } else {     if (delta <= 2.2204e-16 * xNorm) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );     } else {         if (maxCosine <= 2.2204e-16) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );         }     } }
SDL_150:265:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (delta <= 2.2204e-16 * xNorm) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance ); } else {     if (maxCosine <= 2.2204e-16) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );     } }  =>  
SDL_151:266:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance );  =>  
SDL_152:272:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (delta <= 2.2204e-16 * xNorm) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance ); } else {     if (maxCosine <= 2.2204e-16) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );     } }  =>   if (true) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance ); } else {     if (maxCosine <= 2.2204e-16) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );     } }
SDL_153:268:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (maxCosine <= 2.2204e-16) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance ); }  =>  
SDL_154:269:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance );  =>  
SDL_155:271:org.apache.commons.math3.optim.PointVectorValuePair_doOptimize(): if (maxCosine <= 2.2204e-16) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance ); }
SDL_156:393:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_157:393:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_158:388:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_159:390:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_160:395:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_161:392:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_162:378:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_163:395:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_164:387:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_165:393:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_166:395:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_167:393:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_168:346:void_determineLMParameter(double,double,double,double,double,double): final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   final int nC = weightedJacobian[0].length; for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double fp = dxNorm - delta; if (fp <= 0.1 * delta) {     lmPar = 0;     return; } double sum2; double parl = 0; if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; } double gNorm = FastMath.sqrt( sum2 ); double paru = gNorm / delta; if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); } lmPar = FastMath.min( paru, FastMath.max( lmPar, parl ) ); if (lmPar == 0) {     lmPar = gNorm / dxNorm; }
SDL_169:281:void_determineLMParameter(double,double,double,double,double,double): lmDir[permutation[j]] = qy[j];  =>  
SDL_170:283:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; }  =>   for (int j = 0;; ++j) {     lmDir[permutation[j]] = qy[j]; }
SDL_171:283:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < rank; ++j) {     lmDir[permutation[j]] = qy[j]; }  =>   for (int j = 0; j < rank;) {     lmDir[permutation[j]] = qy[j]; }
SDL_172:284:void_determineLMParameter(double,double,double,double,double,double): lmDir[permutation[j]] = 0;  =>  
SDL_173:286:void_determineLMParameter(double,double,double,double,double,double): for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; }  =>   for (int j = rank;; ++j) {     lmDir[permutation[j]] = 0; }
SDL_174:286:void_determineLMParameter(double,double,double,double,double,double): for (int j = rank; j < nC; ++j) {     lmDir[permutation[j]] = 0; }  =>   for (int j = rank; j < nC;) {     lmDir[permutation[j]] = 0; }
SDL_175:290:void_determineLMParameter(double,double,double,double,double,double): int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; for (int i = 0; i < k; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; } lmDir[pk] = ypk;  =>   int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; lmDir[pk] = ypk;
SDL_176:292:void_determineLMParameter(double,double,double,double,double,double): int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; for (int i = 0; i < k; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; } lmDir[pk] = ypk;  =>   int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; for (int i = 0; i < k; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; }
SDL_177:294:void_determineLMParameter(double,double,double,double,double,double): for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; }  =>   for (int k = rank - 1;; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; }
SDL_178:294:void_determineLMParameter(double,double,double,double,double,double): for (int k = rank - 1; k >= 0; --k) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; }  =>   for (int k = rank - 1; k >= 0;) {     int pk = permutation[k];     double ypk = lmDir[pk] / diagR[pk];     for (int i = 0; i < k; ++i) {         lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];     }     lmDir[pk] = ypk; }
SDL_179:290:void_determineLMParameter(double,double,double,double,double,double): lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];  =>  
SDL_180:292:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i < k; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; }  =>   for (int i = 0;; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; }
SDL_181:292:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i < k; ++i) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; }  =>   for (int i = 0; i < k;) {     lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk]; }
SDL_182:299:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work1[pj] = s; dxNorm += s * s;  =>   int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; dxNorm += s * s;
SDL_183:299:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work1[pj] = s; dxNorm += s * s;  =>   int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work1[pj] = s;
SDL_184:301:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; }
SDL_185:301:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work1[pj] = s;     dxNorm += s * s; }
SDL_186:305:void_determineLMParameter(double,double,double,double,double,double): lmPar = 0; return;  =>   return;
SDL_187:307:void_determineLMParameter(double,double,double,double,double,double): if (fp <= 0.1 * delta) {     lmPar = 0;     return; }  =>   if (true) {     lmPar = 0;     return; }
SDL_188:322:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);  =>   sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);
SDL_189:325:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);
SDL_190:316:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; parl = fp / (delta * sum2);
SDL_191:325:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; } parl = fp / (delta * sum2);  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; }
SDL_192:327:void_determineLMParameter(double,double,double,double,double,double): if (rank == solvedCols) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); }  =>   if (true) {     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] *= diag[pj] / dxNorm;     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double sum = 0;         for (int i = 0; i < j; ++i) {             sum += weightedJacobian[i][pj] * work1[permutation[i]];         }         double s = (work1[pj] - sum) / diagR[pj];         work1[pj] = s;         sum2 += s * s;     }     parl = fp / (delta * sum2); }
SDL_193:312:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm;  =>   int pj = permutation[j];
SDL_194:314:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; }
SDL_195:314:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     work1[pj] *= diag[pj] / dxNorm; }
SDL_196:321:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s;  =>   int pj = permutation[j]; double sum = 0; double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s;
SDL_197:323:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s;  =>   int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; sum2 += s * s;
SDL_198:323:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s;  =>   int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s;
SDL_199:325:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; }
SDL_200:325:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i < j; ++i) {         sum += weightedJacobian[i][pj] * work1[permutation[i]];     }     double s = (work1[pj] - sum) / diagR[pj];     work1[pj] = s;     sum2 += s * s; }
SDL_201:319:void_determineLMParameter(double,double,double,double,double,double): sum += weightedJacobian[i][pj] * work1[permutation[i]];  =>  
SDL_202:321:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; }  =>   for (int i = 0;; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; }
SDL_203:321:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i < j; ++i) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; }  =>   for (int i = 0; i < j;) {     sum += weightedJacobian[i][pj] * work1[permutation[i]]; }
SDL_204:333:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum;  =>   int pj = permutation[j]; double sum = 0; sum /= diag[pj]; sum2 += sum * sum;
SDL_205:335:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum;  =>   int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; } sum2 += sum * sum;
SDL_206:335:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum;  =>   int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; } sum /= diag[pj];
SDL_207:337:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; }
SDL_208:337:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double sum = 0;     for (int i = 0; i <= j; ++i) {         sum += weightedJacobian[i][pj] * qy[i];     }     sum /= diag[pj];     sum2 += sum * sum; }
SDL_209:332:void_determineLMParameter(double,double,double,double,double,double): sum += weightedJacobian[i][pj] * qy[i];  =>  
SDL_210:334:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; }  =>   for (int i = 0;; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; }
SDL_211:334:void_determineLMParameter(double,double,double,double,double,double): for (int i = 0; i <= j; ++i) {     sum += weightedJacobian[i][pj] * qy[i]; }  =>   for (int i = 0; i <= j;) {     sum += weightedJacobian[i][pj] * qy[i]; }
SDL_212:340:void_determineLMParameter(double,double,double,double,double,double): paru = 2.2251e-308 / FastMath.min( delta, 0.1 );  =>  
SDL_213:342:void_determineLMParameter(double,double,double,double,double,double): if (paru == 0) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); }  =>   if (true) {     paru = 2.2251e-308 / FastMath.min( delta, 0.1 ); }
SDL_214:344:void_determineLMParameter(double,double,double,double,double,double): lmPar = gNorm / dxNorm;  =>  
SDL_215:346:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = gNorm / dxNorm; }  =>   if (true) {     lmPar = gNorm / dxNorm; }
SDL_216:392:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_217:391:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_218:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_219:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_220:389:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_221:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_222:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_223:392:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_224:391:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_225:387:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_226:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_227:391:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );
SDL_228:388:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); lmPar = FastMath.max( parl, lmPar + correction );
SDL_229:394:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } } lmPar = FastMath.max( parl, lmPar + correction );  =>   if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); } double sPar = FastMath.sqrt( lmPar ); for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; } determineLMDirection( qy, work1, work2, work3 ); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; } dxNorm = FastMath.sqrt( dxNorm ); double previousFP = fp; fp = dxNorm - delta; if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } }
SDL_230:396:void_determineLMParameter(double,double,double,double,double,double): for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   for (int countdown = 10;; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_231:396:void_determineLMParameter(double,double,double,double,double,double): for (int countdown = 10; countdown >= 0; --countdown) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }  =>   for (int countdown = 10; countdown >= 0;) {     if (lmPar == 0) {         lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );     }     double sPar = FastMath.sqrt( lmPar );     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = sPar * diag[pj];     }     determineLMDirection( qy, work1, work2, work3 );     dxNorm = 0;     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         double s = diag[pj] * lmDir[pj];         work3[pj] = s;         dxNorm += s * s;     }     dxNorm = FastMath.sqrt( dxNorm );     double previousFP = fp;     fp = dxNorm - delta;     if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {         return;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] = work3[pj] * diag[pj] / dxNorm;     }     for (int j = 0; j < solvedCols; ++j) {         int pj = permutation[j];         work1[pj] /= work2[j];         double tmp = work1[pj];         for (int i = j + 1; i < solvedCols; ++i) {             work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;         }     }     sum2 = 0;     for (int j = 0; j < solvedCols; ++j) {         double s = work1[permutation[j]];         sum2 += s * s;     }     double correction = fp / (delta * sum2);     if (fp > 0) {         parl = FastMath.max( parl, lmPar );     } else {         if (fp < 0) {             paru = FastMath.min( paru, lmPar );         }     }     lmPar = FastMath.max( parl, lmPar + correction ); }
SDL_232:348:void_determineLMParameter(double,double,double,double,double,double): lmPar = FastMath.max( 2.2251e-308, 0.001 * paru );  =>  
SDL_233:350:void_determineLMParameter(double,double,double,double,double,double): if (lmPar == 0) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); }  =>   if (true) {     lmPar = FastMath.max( 2.2251e-308, 0.001 * paru ); }
SDL_234:353:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; work1[pj] = sPar * diag[pj];  =>   int pj = permutation[j];
SDL_235:355:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; }
SDL_236:355:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     work1[pj] = sPar * diag[pj]; }
SDL_237:361:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s;  =>   int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; dxNorm += s * s;
SDL_238:361:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s;  =>   int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s;
SDL_239:363:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; }
SDL_240:363:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double s = diag[pj] * lmDir[pj];     work3[pj] = s;     dxNorm += s * s; }
SDL_241:369:void_determineLMParameter(double,double,double,double,double,double): if (FastMath.abs( fp ) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {     return; }  =>   if (true) {     return; }
SDL_242:371:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; work1[pj] = work3[pj] * diag[pj] / dxNorm;  =>   int pj = permutation[j];
SDL_243:373:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; }
SDL_244:373:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     work1[pj] = work3[pj] * diag[pj] / dxNorm; }
SDL_245:379:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; work1[pj] /= work2[j]; double tmp = work1[pj]; for (int i = j + 1; i < solvedCols; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }  =>   int pj = permutation[j]; double tmp = work1[pj]; for (int i = j + 1; i < solvedCols; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }
SDL_246:377:void_determineLMParameter(double,double,double,double,double,double): int pj = permutation[j]; work1[pj] /= work2[j]; double tmp = work1[pj]; for (int i = j + 1; i < solvedCols; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }  =>   int pj = permutation[j]; work1[pj] /= work2[j]; double tmp = work1[pj];
SDL_247:381:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } }
SDL_248:381:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     work1[pj] /= work2[j];     double tmp = work1[pj];     for (int i = j + 1; i < solvedCols; ++i) {         work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;     } }
SDL_249:378:void_determineLMParameter(double,double,double,double,double,double): work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;  =>  
SDL_250:380:void_determineLMParameter(double,double,double,double,double,double): for (int i = j + 1; i < solvedCols; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }  =>   for (int i = j + 1;; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }
SDL_251:380:void_determineLMParameter(double,double,double,double,double,double): for (int i = j + 1; i < solvedCols; ++i) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }  =>   for (int i = j + 1; i < solvedCols;) {     work1[permutation[i]] -= weightedJacobian[i][pj] * tmp; }
SDL_252:384:void_determineLMParameter(double,double,double,double,double,double): double s = work1[permutation[j]]; sum2 += s * s;  =>   double s = work1[permutation[j]];
SDL_253:386:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; }  =>   for (int j = 0;; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; }
SDL_254:386:void_determineLMParameter(double,double,double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     double s = work1[permutation[j]];     sum2 += s * s; }  =>   for (int j = 0; j < solvedCols;) {     double s = work1[permutation[j]];     sum2 += s * s; }
SDL_255:388:void_determineLMParameter(double,double,double,double,double,double): parl = FastMath.max( parl, lmPar );  =>  
SDL_256:394:void_determineLMParameter(double,double,double,double,double,double): if (fp > 0) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } }  =>   if (true) {     parl = FastMath.max( parl, lmPar ); } else {     if (fp < 0) {         paru = FastMath.min( paru, lmPar );     } }
SDL_257:390:void_determineLMParameter(double,double,double,double,double,double): if (fp < 0) {     paru = FastMath.min( paru, lmPar ); }  =>  
SDL_258:391:void_determineLMParameter(double,double,double,double,double,double): paru = FastMath.min( paru, lmPar );  =>  
SDL_259:393:void_determineLMParameter(double,double,double,double,double,double): if (fp < 0) {     paru = FastMath.min( paru, lmPar ); }  =>   if (true) {     paru = FastMath.min( paru, lmPar ); }
SDL_260:460:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }
SDL_261:430:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }
SDL_262:460:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }
SDL_263:458:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }
SDL_264:465:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } } for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; } for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; } int nSing = solvedCols; for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } } if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } }
SDL_265:404:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; } lmDir[j] = diagR[pj]; work[j] = qy[j];  =>   int pj = permutation[j]; lmDir[j] = diagR[pj]; work[j] = qy[j];
SDL_266:406:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; } lmDir[j] = diagR[pj]; work[j] = qy[j];  =>   int pj = permutation[j]; for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; } work[j] = qy[j];
SDL_267:406:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; } lmDir[j] = diagR[pj]; work[j] = qy[j];  =>   int pj = permutation[j]; for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; } lmDir[j] = diagR[pj];
SDL_268:408:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; }
SDL_269:408:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     for (int i = j + 1; i < solvedCols; ++i) {         weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];     }     lmDir[j] = diagR[pj];     work[j] = qy[j]; }
SDL_270:403:void_determineLMDirection(double,double,double,double): weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];  =>  
SDL_271:405:void_determineLMDirection(double,double,double,double): for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; }  =>   for (int i = j + 1;; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; }
SDL_272:405:void_determineLMDirection(double,double,double,double): for (int i = j + 1; i < solvedCols; ++i) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; }  =>   for (int i = j + 1; i < solvedCols;) {     weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]]; }
SDL_273:442:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];  =>   int pj = permutation[j]; double dpj = diag[pj]; lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];
SDL_274:444:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];  =>   int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];
SDL_275:418:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];  =>   int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];
SDL_276:444:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];  =>   int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } weightedJacobian[j][permutation[j]] = lmDir[j];
SDL_277:444:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]]; weightedJacobian[j][permutation[j]] = lmDir[j];  =>   int pj = permutation[j]; double dpj = diag[pj]; if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); } lmDiag[j] = dpj; double qtbpj = 0; for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } } lmDiag[j] = weightedJacobian[j][permutation[j]];
SDL_278:446:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; }  =>   for (int j = 0;; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; }
SDL_279:446:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; }  =>   for (int j = 0; j < solvedCols;) {     int pj = permutation[j];     double dpj = diag[pj];     if (dpj != 0) {         Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );     }     lmDiag[j] = dpj;     double qtbpj = 0;     for (int k = j; k < solvedCols; ++k) {         int pk = permutation[k];         if (lmDiag[k] != 0) {             final double sin;             final double cos;             double rkk = weightedJacobian[k][pk];             if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {                 final double cotan = rkk / lmDiag[k];                 sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );                 cos = sin * cotan;             } else {                 final double tan = lmDiag[k] / rkk;                 cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );                 sin = cos * tan;             }             weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];             final double temp = cos * work[k] + sin * qtbpj;             qtbpj = -sin * work[k] + cos * qtbpj;             work[k] = temp;             for (int i = k + 1; i < solvedCols; ++i) {                 double rik = weightedJacobian[i][pk];                 final double temp2 = cos * rik + sin * lmDiag[i];                 lmDiag[i] = -sin * rik + cos * lmDiag[i];                 weightedJacobian[i][pk] = temp2;             }         }     }     lmDiag[j] = weightedJacobian[j][permutation[j]];     weightedJacobian[j][permutation[j]] = lmDir[j]; }
SDL_280:412:void_determineLMDirection(double,double,double,double): Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 );  =>  
SDL_281:414:void_determineLMDirection(double,double,double,double): if (dpj != 0) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); }  =>   if (true) {     Arrays.fill( lmDiag, j + 1, lmDiag.length, 0 ); }
SDL_282:418:void_determineLMDirection(double,double,double,double): int pk = permutation[k]; if (lmDiag[k] != 0) {     final double sin;     final double cos;     double rkk = weightedJacobian[k][pk];     if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {         final double cotan = rkk / lmDiag[k];         sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );         cos = sin * cotan;     } else {         final double tan = lmDiag[k] / rkk;         cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );         sin = cos * tan;     }     weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];     final double temp = cos * work[k] + sin * qtbpj;     qtbpj = -sin * work[k] + cos * qtbpj;     work[k] = temp;     for (int i = k + 1; i < solvedCols; ++i) {         double rik = weightedJacobian[i][pk];         final double temp2 = cos * rik + sin * lmDiag[i];         lmDiag[i] = -sin * rik + cos * lmDiag[i];         weightedJacobian[i][pk] = temp2;     } }  =>   int pk = permutation[k];
SDL_283:443:void_determineLMDirection(double,double,double,double): for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } }  =>   for (int k = j;; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } }
SDL_284:443:void_determineLMDirection(double,double,double,double): for (int k = j; k < solvedCols; ++k) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } }  =>   for (int k = j; k < solvedCols;) {     int pk = permutation[k];     if (lmDiag[k] != 0) {         final double sin;         final double cos;         double rkk = weightedJacobian[k][pk];         if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {             final double cotan = rkk / lmDiag[k];             sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );             cos = sin * cotan;         } else {             final double tan = lmDiag[k] / rkk;             cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );             sin = cos * tan;         }         weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];         final double temp = cos * work[k] + sin * qtbpj;         qtbpj = -sin * work[k] + cos * qtbpj;         work[k] = temp;         for (int i = k + 1; i < solvedCols; ++i) {             double rik = weightedJacobian[i][pk];             final double temp2 = cos * rik + sin * lmDiag[i];             lmDiag[i] = -sin * rik + cos * lmDiag[i];             weightedJacobian[i][pk] = temp2;         }     } }
SDL_285:432:void_determineLMDirection(double,double,double,double): final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   final double sin; final double cos; double rkk = weightedJacobian[k][pk]; weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_286:440:void_determineLMDirection(double,double,double,double): final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_287:440:void_determineLMDirection(double,double,double,double): final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_288:440:void_determineLMDirection(double,double,double,double): final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_289:435:void_determineLMDirection(double,double,double,double): final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp; for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   final double sin; final double cos; double rkk = weightedJacobian[k][pk]; if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; } weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k]; final double temp = cos * work[k] + sin * qtbpj; qtbpj = -sin * work[k] + cos * qtbpj; work[k] = temp;
SDL_290:442:void_determineLMDirection(double,double,double,double): if (lmDiag[k] != 0) {     final double sin;     final double cos;     double rkk = weightedJacobian[k][pk];     if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {         final double cotan = rkk / lmDiag[k];         sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );         cos = sin * cotan;     } else {         final double tan = lmDiag[k] / rkk;         cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );         sin = cos * tan;     }     weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];     final double temp = cos * work[k] + sin * qtbpj;     qtbpj = -sin * work[k] + cos * qtbpj;     work[k] = temp;     for (int i = k + 1; i < solvedCols; ++i) {         double rik = weightedJacobian[i][pk];         final double temp2 = cos * rik + sin * lmDiag[i];         lmDiag[i] = -sin * rik + cos * lmDiag[i];         weightedJacobian[i][pk] = temp2;     } }  =>   if (true) {     final double sin;     final double cos;     double rkk = weightedJacobian[k][pk];     if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {         final double cotan = rkk / lmDiag[k];         sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );         cos = sin * cotan;     } else {         final double tan = lmDiag[k] / rkk;         cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );         sin = cos * tan;     }     weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];     final double temp = cos * work[k] + sin * qtbpj;     qtbpj = -sin * work[k] + cos * qtbpj;     work[k] = temp;     for (int i = k + 1; i < solvedCols; ++i) {         double rik = weightedJacobian[i][pk];         final double temp2 = cos * rik + sin * lmDiag[i];         lmDiag[i] = -sin * rik + cos * lmDiag[i];         weightedJacobian[i][pk] = temp2;     } }
SDL_291:425:void_determineLMDirection(double,double,double,double): final double cotan = rkk / lmDiag[k]; sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan ); cos = sin * cotan;  =>   final double cotan = rkk / lmDiag[k]; cos = sin * cotan;
SDL_292:425:void_determineLMDirection(double,double,double,double): final double cotan = rkk / lmDiag[k]; sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan ); cos = sin * cotan;  =>   final double cotan = rkk / lmDiag[k]; sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );
SDL_293:431:void_determineLMDirection(double,double,double,double): if (FastMath.abs( rkk ) < FastMath.abs( lmDiag[k] )) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; }  =>   if (true) {     final double cotan = rkk / lmDiag[k];     sin = 1.0 / FastMath.sqrt( 1.0 + cotan * cotan );     cos = sin * cotan; } else {     final double tan = lmDiag[k] / rkk;     cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );     sin = cos * tan; }
SDL_294:429:void_determineLMDirection(double,double,double,double): final double tan = lmDiag[k] / rkk; cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan ); sin = cos * tan;  =>   final double tan = lmDiag[k] / rkk; sin = cos * tan;
SDL_295:429:void_determineLMDirection(double,double,double,double): final double tan = lmDiag[k] / rkk; cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan ); sin = cos * tan;  =>   final double tan = lmDiag[k] / rkk; cos = 1.0 / FastMath.sqrt( 1.0 + tan * tan );
SDL_296:439:void_determineLMDirection(double,double,double,double): double rik = weightedJacobian[i][pk]; final double temp2 = cos * rik + sin * lmDiag[i]; lmDiag[i] = -sin * rik + cos * lmDiag[i]; weightedJacobian[i][pk] = temp2;  =>   double rik = weightedJacobian[i][pk]; final double temp2 = cos * rik + sin * lmDiag[i]; weightedJacobian[i][pk] = temp2;
SDL_297:439:void_determineLMDirection(double,double,double,double): double rik = weightedJacobian[i][pk]; final double temp2 = cos * rik + sin * lmDiag[i]; lmDiag[i] = -sin * rik + cos * lmDiag[i]; weightedJacobian[i][pk] = temp2;  =>   double rik = weightedJacobian[i][pk]; final double temp2 = cos * rik + sin * lmDiag[i]; lmDiag[i] = -sin * rik + cos * lmDiag[i];
SDL_298:441:void_determineLMDirection(double,double,double,double): for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   for (int i = k + 1;; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_299:441:void_determineLMDirection(double,double,double,double): for (int i = k + 1; i < solvedCols; ++i) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }  =>   for (int i = k + 1; i < solvedCols;) {     double rik = weightedJacobian[i][pk];     final double temp2 = cos * rik + sin * lmDiag[i];     lmDiag[i] = -sin * rik + cos * lmDiag[i];     weightedJacobian[i][pk] = temp2; }
SDL_300:451:void_determineLMDirection(double,double,double,double): if (lmDiag[j] == 0 && nSing == solvedCols) {     nSing = j; } if (nSing < solvedCols) {     work[j] = 0; }  =>   if (nSing < solvedCols) {     work[j] = 0; }
SDL_301:451:void_determineLMDirection(double,double,double,double): if (lmDiag[j] == 0 && nSing == solvedCols) {     nSing = j; } if (nSing < solvedCols) {     work[j] = 0; }  =>   if (lmDiag[j] == 0 && nSing == solvedCols) {     nSing = j; }
SDL_302:455:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } }  =>   for (int j = 0;; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } }
SDL_303:455:void_determineLMDirection(double,double,double,double): for (int j = 0; j < solvedCols; ++j) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } }  =>   for (int j = 0; j < solvedCols;) {     if (lmDiag[j] == 0 && nSing == solvedCols) {         nSing = j;     }     if (nSing < solvedCols) {         work[j] = 0;     } }
SDL_304:449:void_determineLMDirection(double,double,double,double): nSing = j;  =>  
SDL_305:451:void_determineLMDirection(double,double,double,double): if (lmDiag[j] == 0 && nSing == solvedCols) {     nSing = j; }  =>   if (true) {     nSing = j; }
SDL_306:452:void_determineLMDirection(double,double,double,double): work[j] = 0;  =>  
SDL_307:454:void_determineLMDirection(double,double,double,double): if (nSing < solvedCols) {     work[j] = 0; }  =>   if (true) {     work[j] = 0; }
SDL_308:456:void_determineLMDirection(double,double,double,double): for (int j = nSing - 1; j >= 0; --j) {     int pj = permutation[j];     double sum = 0;     for (int i = j + 1; i < nSing; ++i) {         sum += weightedJacobian[i][pj] * work[i];     }     work[j] = (work[j] - sum) / lmDiag[j]; }  =>  
SDL_309:465:void_determineLMDirection(double,double,double,double): if (nSing > 0) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } }  =>   if (true) {     for (int j = nSing - 1; j >= 0; --j) {         int pj = permutation[j];         double sum = 0;         for (int i = j + 1; i < nSing; ++i) {             sum += weightedJacobian[i][pj] * work[i];         }         work[j] = (work[j] - sum) / lmDiag[j];     } }
SDL_310:460:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = j + 1; i < nSing; ++i) {     sum += weightedJacobian[i][pj] * work[i]; } work[j] = (work[j] - sum) / lmDiag[j];  =>   int pj = permutation[j]; double sum = 0; work[j] = (work[j] - sum) / lmDiag[j];
SDL_311:462:void_determineLMDirection(double,double,double,double): int pj = permutation[j]; double sum = 0; for (int i = j + 1; i < nSing; ++i) {     sum += weightedJacobian[i][pj] * work[i]; } work[j] = (work[j] - sum) / lmDiag[j];  =>   int pj = permutation[j]; double sum = 0; for (int i = j + 1; i < nSing; ++i) {     sum += weightedJacobian[i][pj] * work[i]; }
SDL_312:464:void_determineLMDirection(double,double,double,double): for (int j = nSing - 1; j >= 0; --j) {     int pj = permutation[j];     double sum = 0;     for (int i = j + 1; i < nSing; ++i) {         sum += weightedJacobian[i][pj] * work[i];     }     work[j] = (work[j] - sum) / lmDiag[j]; }  =>   for (int j = nSing - 1;; --j) {     int pj = permutation[j];     double sum = 0;     for (int i = j + 1; i < nSing; ++i) {         sum += weightedJacobian[i][pj] * work[i];     }     work[j] = (work[j] - sum) / lmDiag[j]; }
SDL_313:464:void_determineLMDirection(double,double,double,double): for (int j = nSing - 1; j >= 0; --j) {     int pj = permutation[j];     double sum = 0;     for (int i = j + 1; i < nSing; ++i) {         sum += weightedJacobian[i][pj] * work[i];     }     work[j] = (work[j] - sum) / lmDiag[j]; }  =>   for (int j = nSing - 1; j >= 0;) {     int pj = permutation[j];     double sum = 0;     for (int i = j + 1; i < nSing; ++i) {         sum += weightedJacobian[i][pj] * work[i];     }     work[j] = (work[j] - sum) / lmDiag[j]; }
SDL_314:460:void_determineLMDirection(double,double,double,double): sum += weightedJacobian[i][pj] * work[i];  =>  
SDL_315:462:void_determineLMDirection(double,double,double,double): for (int i = j + 1; i < nSing; ++i) {     sum += weightedJacobian[i][pj] * work[i]; }  =>   for (int i = j + 1;; ++i) {     sum += weightedJacobian[i][pj] * work[i]; }
SDL_316:462:void_determineLMDirection(double,double,double,double): for (int i = j + 1; i < nSing; ++i) {     sum += weightedJacobian[i][pj] * work[i]; }  =>   for (int i = j + 1; i < nSing;) {     sum += weightedJacobian[i][pj] * work[i]; }
SDL_317:466:void_determineLMDirection(double,double,double,double): lmDir[permutation[j]] = work[j];  =>  
SDL_318:468:void_determineLMDirection(double,double,double,double): for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0;; ++j) {     lmDir[permutation[j]] = work[j]; }
SDL_319:468:void_determineLMDirection(double,double,double,double): for (int j = 0; j < lmDir.length; ++j) {     lmDir[permutation[j]] = work[j]; }  =>   for (int j = 0; j < lmDir.length;) {     lmDir[permutation[j]] = work[j]; }
SDL_320:526:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;  =>   final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;
SDL_321:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;  =>   weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;
SDL_322:486:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;  =>   weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } rank = solvedCols;
SDL_323:526:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } } rank = solvedCols;  =>   weightedJacobian = jacobian.scalarMultiply( -1 ).getData(); final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); } for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } }
SDL_324:483:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): permutation[k] = k; double norm2 = 0; for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; } jacNorm[k] = FastMath.sqrt( norm2 );  =>   double norm2 = 0; for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; } jacNorm[k] = FastMath.sqrt( norm2 );
SDL_325:480:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): permutation[k] = k; double norm2 = 0; for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; } jacNorm[k] = FastMath.sqrt( norm2 );  =>   permutation[k] = k; double norm2 = 0; jacNorm[k] = FastMath.sqrt( norm2 );
SDL_326:483:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): permutation[k] = k; double norm2 = 0; for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; } jacNorm[k] = FastMath.sqrt( norm2 );  =>   permutation[k] = k; double norm2 = 0; for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; }
SDL_327:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); }  =>   for (int k = 0;; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); }
SDL_328:485:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int k = 0; k < nC; ++k) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); }  =>   for (int k = 0; k < nC;) {     permutation[k] = k;     double norm2 = 0;     for (int i = 0; i < nR; ++i) {         double akk = weightedJacobian[i][k];         norm2 += akk * akk;     }     jacNorm[k] = FastMath.sqrt( norm2 ); }
SDL_329:481:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double akk = weightedJacobian[i][k]; norm2 += akk * akk;  =>   double akk = weightedJacobian[i][k];
SDL_330:483:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; }  =>   for (int i = 0;; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; }
SDL_331:483:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int i = 0; i < nR; ++i) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; }  =>   for (int i = 0; i < nR;) {     double akk = weightedJacobian[i][k];     norm2 += akk * akk; }
SDL_332:511:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_333:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_334:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_335:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_336:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_337:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_338:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_339:515:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha; for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   int nextColumn = -1; double ak2 = Double.NEGATIVE_INFINITY; for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } } if (ak2 <= qrRankingThreshold) {     rank = k;     return; } int pk = permutation[nextColumn]; permutation[nextColumn] = permutation[k]; permutation[k] = pk; double akk = weightedJacobian[k][pk]; double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 ); double betak = 1.0 / (ak2 - akk * alpha); beta[pk] = betak; diagR[pk] = alpha; weightedJacobian[k][pk] -= alpha;
SDL_340:526:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } }  =>   for (int k = 0;; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } }
SDL_341:526:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int k = 0; k < nC; ++k) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } }  =>   for (int k = 0; k < nC;) {     int nextColumn = -1;     double ak2 = Double.NEGATIVE_INFINITY;     for (int i = k; i < nC; ++i) {         double norm2 = 0;         for (int j = k; j < nR; ++j) {             double aki = weightedJacobian[j][permutation[i]];             norm2 += aki * aki;         }         if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {             throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );         }         if (norm2 > ak2) {             nextColumn = i;             ak2 = norm2;         }     }     if (ak2 <= qrRankingThreshold) {         rank = k;         return;     }     int pk = permutation[nextColumn];     permutation[nextColumn] = permutation[k];     permutation[k] = pk;     double akk = weightedJacobian[k][pk];     double alpha = akk > 0 ? -FastMath.sqrt( ak2 ) : FastMath.sqrt( ak2 );     double betak = 1.0 / (ak2 - akk * alpha);     beta[pk] = betak;     diagR[pk] = alpha;     weightedJacobian[k][pk] -= alpha;     for (int dk = nC - 1 - k; dk > 0; --dk) {         double gamma = 0;         for (int j = k; j < nR; ++j) {             gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];         }         gamma *= betak;         for (int j = k; j < nR; ++j) {             weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];         }     } }
SDL_342:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double norm2 = 0; for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; } if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); } if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }  =>   double norm2 = 0; if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); } if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }
SDL_343:498:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double norm2 = 0; for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; } if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); } if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }  =>   double norm2 = 0; for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; } if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }
SDL_344:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double norm2 = 0; for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; } if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); } if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }  =>   double norm2 = 0; for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; } if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); }
SDL_345:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } }  =>   for (int i = k;; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } }
SDL_346:502:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int i = k; i < nC; ++i) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } }  =>   for (int i = k; i < nC;) {     double norm2 = 0;     for (int j = k; j < nR; ++j) {         double aki = weightedJacobian[j][permutation[i]];         norm2 += aki * aki;     }     if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {         throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );     }     if (norm2 > ak2) {         nextColumn = i;         ak2 = norm2;     } }
SDL_347:492:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double aki = weightedJacobian[j][permutation[i]]; norm2 += aki * aki;  =>   double aki = weightedJacobian[j][permutation[i]];
SDL_348:494:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; }  =>   for (int j = k;; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; }
SDL_349:494:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; }  =>   for (int j = k; j < nR;) {     double aki = weightedJacobian[j][permutation[i]];     norm2 += aki * aki; }
SDL_350:495:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC );  =>  
SDL_351:497:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): if (Double.isInfinite( norm2 ) || Double.isNaN( norm2 )) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.ConvergenceException( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, nR, nC ); }
SDL_352:499:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): nextColumn = i; ak2 = norm2;  =>   ak2 = norm2;
SDL_353:499:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): nextColumn = i; ak2 = norm2;  =>   nextColumn = i;
SDL_354:501:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): if (norm2 > ak2) {     nextColumn = i;     ak2 = norm2; }  =>   if (true) {     nextColumn = i;     ak2 = norm2; }
SDL_355:504:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): rank = k; return;  =>   return;
SDL_356:506:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): if (ak2 <= qrRankingThreshold) {     rank = k;     return; }  =>   if (true) {     rank = k;     return; }
SDL_357:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double gamma = 0; for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; } gamma *= betak; for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }  =>   double gamma = 0; gamma *= betak; for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }
SDL_358:523:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double gamma = 0; for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; } gamma *= betak; for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }  =>   double gamma = 0; for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; } for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }
SDL_359:521:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): double gamma = 0; for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; } gamma *= betak; for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }  =>   double gamma = 0; for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; } gamma *= betak;
SDL_360:525:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   for (int dk = nC - 1 - k;; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_361:525:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int dk = nC - 1 - k; dk > 0; --dk) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }  =>   for (int dk = nC - 1 - k; dk > 0;) {     double gamma = 0;     for (int j = k; j < nR; ++j) {         gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];     }     gamma *= betak;     for (int j = k; j < nR; ++j) {         weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];     } }
SDL_362:518:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];  =>  
SDL_363:520:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; }  =>   for (int j = k;; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; }
SDL_364:520:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; }  =>   for (int j = k; j < nR;) {     gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]]; }
SDL_365:522:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];  =>  
SDL_366:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }  =>   for (int j = k;; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }
SDL_367:524:void_qrDecomposition(org.apache.commons.math3.linear.RealMatrix): for (int j = k; j < nR; ++j) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }  =>   for (int j = k; j < nR;) {     weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk]; }
SDL_368:533:void_qTy(double): final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length; for (int k = 0; k < nC; ++k) {     int pk = permutation[k];     double gamma = 0;     for (int i = k; i < nR; ++i) {         gamma += weightedJacobian[i][pk] * y[i];     }     gamma *= beta[pk];     for (int i = k; i < nR; ++i) {         y[i] -= gamma * weightedJacobian[i][pk];     } }  =>   final int nR = weightedJacobian.length; final int nC = weightedJacobian[0].length;
SDL_369:540:void_qTy(double): int pk = permutation[k]; double gamma = 0; for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; } gamma *= beta[pk]; for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }  =>   int pk = permutation[k]; double gamma = 0; gamma *= beta[pk]; for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }
SDL_370:542:void_qTy(double): int pk = permutation[k]; double gamma = 0; for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; } gamma *= beta[pk]; for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }  =>   int pk = permutation[k]; double gamma = 0; for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; } for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }
SDL_371:540:void_qTy(double): int pk = permutation[k]; double gamma = 0; for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; } gamma *= beta[pk]; for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }  =>   int pk = permutation[k]; double gamma = 0; for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; } gamma *= beta[pk];
SDL_372:544:void_qTy(double): for (int k = 0; k < nC; ++k) {     int pk = permutation[k];     double gamma = 0;     for (int i = k; i < nR; ++i) {         gamma += weightedJacobian[i][pk] * y[i];     }     gamma *= beta[pk];     for (int i = k; i < nR; ++i) {         y[i] -= gamma * weightedJacobian[i][pk];     } }  =>   for (int k = 0;; ++k) {     int pk = permutation[k];     double gamma = 0;     for (int i = k; i < nR; ++i) {         gamma += weightedJacobian[i][pk] * y[i];     }     gamma *= beta[pk];     for (int i = k; i < nR; ++i) {         y[i] -= gamma * weightedJacobian[i][pk];     } }
SDL_373:544:void_qTy(double): for (int k = 0; k < nC; ++k) {     int pk = permutation[k];     double gamma = 0;     for (int i = k; i < nR; ++i) {         gamma += weightedJacobian[i][pk] * y[i];     }     gamma *= beta[pk];     for (int i = k; i < nR; ++i) {         y[i] -= gamma * weightedJacobian[i][pk];     } }  =>   for (int k = 0; k < nC;) {     int pk = permutation[k];     double gamma = 0;     for (int i = k; i < nR; ++i) {         gamma += weightedJacobian[i][pk] * y[i];     }     gamma *= beta[pk];     for (int i = k; i < nR; ++i) {         y[i] -= gamma * weightedJacobian[i][pk];     } }
SDL_374:537:void_qTy(double): gamma += weightedJacobian[i][pk] * y[i];  =>  
SDL_375:539:void_qTy(double): for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; }  =>   for (int i = k;; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; }
SDL_376:539:void_qTy(double): for (int i = k; i < nR; ++i) {     gamma += weightedJacobian[i][pk] * y[i]; }  =>   for (int i = k; i < nR;) {     gamma += weightedJacobian[i][pk] * y[i]; }
SDL_377:541:void_qTy(double): y[i] -= gamma * weightedJacobian[i][pk];  =>  
SDL_378:543:void_qTy(double): for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }  =>   for (int i = k;; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }
SDL_379:543:void_qTy(double): for (int i = k; i < nR; ++i) {     y[i] -= gamma * weightedJacobian[i][pk]; }  =>   for (int i = k; i < nR;) {     y[i] -= gamma * weightedJacobian[i][pk]; }
SDL_380:548:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>  
SDL_381:549:void_checkParameters(): throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT );  =>  
SDL_382:551:void_checkParameters(): if (getLowerBound() != null || getUpperBound() != null) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }  =>   if (true) {     throw new org.apache.commons.math3.exception.MathUnsupportedOperationException( LocalizedFormats.CONSTRAINT ); }
